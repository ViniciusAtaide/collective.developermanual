# SOME DESCRIPTIVE TITLE.
# Copyright (C) Plone community and other individual contributors
# This file is distributed under the same license as the Plone Developer Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Plone Developer Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-09 14:22+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../security/csrf.rst:2
# bbc98745ee374a25ada7e02112cc6c0c
msgid "Cross-Site Request Forgery (CSRF)"
msgstr ""

#: ../../security/csrf.rst:5
# 0abfba08d32b41cbba5eeb66a9383b94
msgid "Plain usage"
msgstr ""

#: ../../security/csrf.rst:7
# bf115979489a46608029103f4b7b3e08
msgid "Documentation: https://github.com/plone/plone.protect/"
msgstr ""

#: ../../security/csrf.rst:10
# 528c9db90fec4636aa5fcf1f5176c1e8
msgid "z3c.form"
msgstr ""

#: ../../security/csrf.rst:12
# 06b7ddf0072046858530f76142baf0d1
msgid "z3c.form does not incude csrf protection yet: https://bugs.launchpad.net/z3c.form/+bug/805794"
msgstr ""

#: ../../security/custom_permissions.rst:3
# d57cb84f7c09413e90b31342de9b7734
msgid "Custom permissions"
msgstr ""

#: ../../security/custom_permissions.rst:5
# 29e444f3067d484eae32235e534a294f
msgid "Creating special permissions for your product"
msgstr ""

#: ../../security/custom_permissions.rst:9
# 6b92177728cc45a48a25424817ee2bf7
msgid "Define Zope 2 permissions in python code"
msgstr ""

#: ../../security/custom_permissions.rst:11
# e036ee0689024bbd8726744b6a666064
msgid "If you want to protect certain actions in your product by a special permission, you most likely will want to assign this permission to a role when the product is installed.  You will want to use Generic Setup's rolemap.xml to assign these permissions.  A new permission will be added to the Zope instance by calling setDefaultRoles on it."
msgstr ""

#: ../../security/custom_permissions.rst:17
# c67eba21378e4fd488baa2f7e636d366
msgid "However, at the time when Generic Setup is run, almost none of your code has actually been run, so the permission doesn't exist yet.  That's why we define the permissions in permissions.py, and call this from __init__.py:"
msgstr ""

#: ../../security/custom_permissions.rst:40
# ac20899579fb48d7828eeafa36500d83
msgid "When working with permissions, always use the variable name instead of the string value.  This ensures that you can't make typos with the string value, which are hard to debug.  If you do make a typo in the variable name, you'll get an ImportError or NameError."
msgstr ""

#: ../../security/custom_permissions.rst:47
# 7c3e86c2c7ec49a99d9b07c3be2aa2d4
msgid "Make the permissions available as a Zope 3 permissions"
msgstr ""

#: ../../security/custom_permissions.rst:49
# 127a8f6d7b5f41eab77f5bdc7e39031a
msgid "To use your permissions with BrowserViews/formlib/z3c.form, you need to make them available available as Zope 3 permissions. This is done in ZCML using a the <permission> directive. Example configure.zcml:"
msgstr ""

#: ../../security/custom_permissions.rst:65
# 96d82a0b85ac453480f559948f3ccdd5
msgid "It's convention to prefix the permission id with the name of the package it's defined in and use lower case only. You have to take care that the title matches exactly the permission string you used in permissions.py. Otherwise a different, zope 3 only, permission is registered."
msgstr ""

#: ../../security/custom_permissions.rst:71
# 8406b5162b10426cbcc97bd0cff0a602
msgid "You can use the permission to e.g. protect BrowserViews. Example configure.zcml:"
msgstr ""

#: ../../security/custom_permissions.rst:95
# 2edda6b786284a8a84c61da76cace017
msgid "Define both Zope 2 and Zope3 permissions in one Step in ZCML"
msgstr ""

#: ../../security/custom_permissions.rst:97
# 57745568aff9442c94acfe8df2ff3198
msgid "You can use `collective.autopermission <http://pypi.python.org/pypi/collective.autopermission/1.0b1>`_ (`svn repository <http://svn.plone.org/svn/collective/collective.autopermission>`_) and define both the Zope 2 and Zope 3 permission at once with the <permission> zcml-directive. To do that install collective.autopermission. Either add \"collective.autopermission\" to \"install_requires\" in setup.py or to your buildout. Then include collective.autopermission's configure.zcml *before* you define the permissions *and* before you use them.  (collective.autopermission is not required in Zope 2.12/Plone 4 anymore!)"
msgstr ""

#: ../../security/custom_permissions.rst:131
# d0ad2f09cf424d3a8f265bbcbcab72be
msgid "Now you can use the permission both as a Zope 2 permission *('MyProduct: MyPermission')* or a Zope 3 permission *('myproduct.mypermission')*. The only disadvantage is that you can't import the permissionstring as a variable from permissions.py."
msgstr ""

#: ../../security/dynamic_roles.rst:3
# 49f0517ebb554635aac684ed0ee23947
msgid "Dynamic roles"
msgstr ""

#: ../../security/dynamic_roles.rst:8
#: ../../security/local_roles.rst:12
#: ../../security/permissions.rst:12
#: ../../security/sandboxing.rst:14
#: ../../security/selinux.rst:12
# 13ab18d4d8a34042ad1188a4804edede
# b49f419163d24482a170d115482129ad
# 22e14f551a2244e587f35c744110f458
# 30a5dd80613142408a23cdc1f50e59c6
# 9f7f46bdde274a86b75536a436215306
msgid "Introduction"
msgstr ""

#: ../../security/dynamic_roles.rst:10
# 662bf85f28804b6d9bf79ec2e58a0744
msgid "Plone core's borg.localrole package allows you to hook into role-resolving code and add roles dynamically. I.e. the role on the user depends on HTTP request / environment conditions and is not something set in the site database."
msgstr ""

#: ../../security/dynamic_roles.rst:15
# 8d93e59b0fce4353905c9e9a2adc3c2a
msgid "Creating a dynamic role"
msgstr ""

#: ../../security/dynamic_roles.rst:17
# 7ce308c8a33945b38cbcd8247cebc805
msgid "First :doc:`create an Ploneadd-on for your coding needs </getstarted/paste>`."
msgstr ""

#: ../../security/dynamic_roles.rst:19
# b20fc20be46145c686de49250b86113a
msgid "getRoles() function is called several times per request so you might want to cache the result."
msgstr ""

#: ../../security/dynamic_roles.rst:22
# f6bab6fd451c4e389cc6e1d4618f4793
msgid "There is a complex example below."
msgstr ""

#: ../../security/dynamic_roles.rst:24
# 2397a07ddc3b4c168964eb0148502054
msgid "getAllRoles() is overridden to return a custom role which is not available through normal security machinery. This is required because Plone/Zope builds look-up tables based on the result of getAllRoles() and all possible roles must appear there"
msgstr ""

#: ../../security/dynamic_roles.rst:29
# 284112258dce4de6ab7aa16db8a1e49a
msgid "getRoles() is overridden to call custom getDummyRolesOnContext() which has the actual logic to resolve the roles"
msgstr ""

#: ../../security/dynamic_roles.rst:32
# cc27b31622ee4fa89dd7fab6cc003ff7
msgid "An example code checks whether the context object implements a marker interface and gives the user a role based on that"
msgstr ""

#: ../../security/dynamic_roles.rst:35
# 84269e0c72e843d58b45f83a7c9181c7
msgid "Example ``localroles.py``::"
msgstr ""

#: ../../security/dynamic_roles.rst:90
# c18f52b933df4f2e95edaaf184cb12c6
msgid "Custom local role implementation is made effective using ZCML adapter directive in your add-ons ``configure.zcml``::"
msgstr ""

#: ../../security/dynamic_roles.rst:105
# c33efa7b2d0445f6ad225b8a51d48f79
msgid "If your dynamic role is not any of Plone's existing roles you need to :doc:`declare it with rolemap.xml </security/local_roles>`."
msgstr ""

#: ../../security/index.rst:3
# 8410e99996b4434a9d3d3e33abd0c41c
msgid "Security"
msgstr ""

#: ../../security/index.rst:5
# be615c0ddc5b4e0183e12a4e676e1259
msgid "Zope provides various built-in security facilities"
msgstr ""

#: ../../security/index.rst:7
# 96183937f1ad48b6ab8bc47c81b8c1b4
msgid "User - role - permission three layer security model"
msgstr ""

#: ../../security/index.rst:9
# bae9ecbb00c8478399b46de9235398cd
msgid "Security declarations in ZCML for views, adapters, etc."
msgstr ""

#: ../../security/index.rst:11
# 9481d84705d74067976ad5d56be170f7
msgid "RestrictedPython to evaluate sandboxed code"
msgstr ""

#: ../../security/local_roles.rst:3
# fbe01949c31642cc949189dc5da4c733
msgid "Local roles"
msgstr ""

#: ../../security/local_roles.rst:5
#: ../../security/permission_lists.rst:5
#: ../../security/permissions.rst:5
#: ../../security/sandboxing.rst:5
#: ../../security/selinux.rst:5
# 399d85a7c21045759601b9e87c5ed774
# 0a32f64e711c47d090b5457f868f0ded
# d0f4f986fe7f4314a36222fdf229b97b
# 9df98459109d4d068ae6334b2bbb1b0e
# 123021b688874bf58d01be74269c6d87
msgid "Description"
msgstr ""

#: ../../security/local_roles.rst:7
# 6a11916a434b42a793aabdf54dcec6f8
msgid "Creating and setting local roles of Plone members programmatically."
msgstr ""

#: ../../security/local_roles.rst:14
# c3c25e9d44c8462aa1b1b685551a9244
msgid "Local roles allows user accounts to have special privileges for a folder and its children."
msgstr ""

#: ../../security/local_roles.rst:17
# 970d9db956944d768e11b21194a18dce
msgid "By default Plone has roles like ``Contributor``, ``Reader``, ``Editor``, etc. and you can view these on the :guilabel:`Sharing` tab and in :term:`ZMI` :guilabel:`Security` tab."
msgstr ""

#: ../../security/local_roles.rst:21
# 45bbd94df2a54b5a9c46844647d1db96
msgid "Good introduction to roles: `Basic Roles and Permissions in Plone <http://www.sixfeetup.com/blog/basic-roles-and-permissions-in-plone>`_"
msgstr ""

#: ../../security/local_roles.rst:26
# 0fe4273601f44657b961d018fed0c70e
msgid "Creating a new role"
msgstr ""

#: ../../security/local_roles.rst:28
# d2981b28af1041a09704740603979957
msgid "New Plone roles can be created through the :doc:`GenericSetup rolemap.xml </components/genericsetup>` file."
msgstr ""

#: ../../security/local_roles.rst:31
# 55098ce8a1b4451e9e9459c8146b78f8
msgid "Example ``profiles/default/rolemap.xml``"
msgstr ""

#: ../../security/local_roles.rst:47
# 7dccfc2dd0be45bd850ebd60cb1c0618
msgid "Adding a role to the Sharing Tab"
msgstr ""

#: ../../security/local_roles.rst:49
# 35d43020744d47a9a0219654ed4b6238
msgid "To let the newly created role appear in the @@sharing tab, create a :doc:`GenericSetup sharing.xml </components/genericsetup>` file."
msgstr ""

#: ../../security/local_roles.rst:52
# a094fff1f4b347f2bdfc605974cea0b8
msgid "Example ``profiles/default/sharing.xml``"
msgstr ""

#: ../../security/local_roles.rst:66
# d5d573174bdb4227a14dd1b574c29458
msgid "The title is the name to be shown on the sharing page. The required_permission is optional. If given, the user must have this permission to be allowed to manage the particular role."
msgstr ""

#: ../../security/local_roles.rst:72
# d4cf3fc4339649ce9ffdecf055819f28
msgid "For Plone 3, there is the `collective.sharingroles <https://pypi.python.org/pypi/collective.sharingroles>`_ addon. Since Plone 4, this is `merged into plone.app.workflow <https://github.com/plone/plone.app.workflow/commit/f9991ca0cc3dd2b8a2c392c145f44c21996eac67>`_."
msgstr ""

#: ../../security/local_roles.rst:77
# 9df94aa39dff4ecfbbbcfdfa8a68df04
msgid "Setting local role"
msgstr ""

#: ../../security/local_roles.rst:79
# 8f091d056fb042ea9e24c6cd21b3c022
msgid "``manage_setLocalRoles`` is defined in `AccessControl.Role.RoleManager <http://svn.zope.org/Zope/trunk/src/AccessControl/Role.py?rev=96262&view=markup>`_."
msgstr ""

#: ../../security/local_roles.rst:81
#: ../../security/local_roles.rst:94
#: ../../security/permissions.rst:167
# 41c00b7a6f4640a78d20360d14cbe5ec
# 75dab7ee545140f1a9f25c0a3baf6112
# ba1deaceae6d47faaea54b54fb251ac3
msgid "Example::"
msgstr ""

#: ../../security/local_roles.rst:87
# 9299c675eba74da2821874e2749d212e
msgid "Getting local roles"
msgstr ""

#: ../../security/local_roles.rst:89
# bcfe926c325f4619aed8bfa47826c1cd
msgid "The ``get_local_roles()`` method returns currently-set local roles. This does not return all the *effective* roles (which may include roles acquired from the parent hierarchy). ``get_local_roles_for_userid()`` returns roles for a particular user as a tuple."
msgstr ""

#: ../../security/local_roles.rst:101
# f53f3655fa614903931b2fc724caf763
msgid "Deleting local roles"
msgstr ""

#: ../../security/local_roles.rst:103
# 2012c672937542fdb683d0ce5d69c9e0
msgid "``manage_delLocalRoles(userids)`` takes a *list of usernames* as argument. All local roles for these users will be cleared."
msgstr ""

#: ../../security/local_roles.rst:106
# 93fd24bd8b45479a8c2cf8150c4753f1
msgid "The following example (``membrane``-specific) will reset local roles based on external input ::"
msgstr ""

#: ../../security/local_roles.rst:145
# 066f9256acd04d1bbc0195376a63743a
msgid "Local role caching"
msgstr ""

#: ../../security/local_roles.rst:147
# c4a83a4fa55e4aeeb3ecca57bc5d6c43
msgid "Resolving effective local roles is a cumbersome operation, so the result is cached."
msgstr ""

#: ../../security/local_roles.rst:150
# a83caaf200084897bb995c381812bc33
msgid "**Unit testers**: Local roles are cached per request. You need to clear this cache after modifying an object's local roles or switching user if you want to get proper readings."
msgstr ""

#: ../../security/local_roles.rst:154
# 1daf8e37099146719c8ceeab47de6410
msgid "Unit test example method::"
msgstr ""

#: ../../security/local_roles.rst:169
# 8fc2d451c34f46419a12e7fcce3c5ada
msgid "Debugging"
msgstr ""

#: ../../security/local_roles.rst:171
# c0e9469506a54e47bb12593295e0b4da
msgid "Set your breakpoint in ``Products.PlonePAS.plugins.local_role.LocalRolesManager.getRolesInContext()`` and ``Products.PlonePAS.plugins.role.GroupAwareRoleManager.getRolesForPrincipal()``. There you see how roles for a given context are being resolved."
msgstr ""

#: ../../security/local_roles.rst:175
# 6cc97435fedf4e13908ddf1b4811b914
msgid "Check the ``acl_users.portal_role_manager`` tool via the :term:`ZMI`."
msgstr ""

#: ../../security/local_roles.rst:177
# b8c159617db74438b29a9f9842964721
msgid "Please see the `zopyx.plone.cassandra <http://pypi.python.org/pypi/zopyx.plone.cassandra>`_ add-on product."
msgstr ""

#: ../../security/local_roles.rst:180
# 3b360645d20e44ad8c5d437c10bfcd9c
msgid "Other"
msgstr ""

#: ../../security/local_roles.rst:182
# 4a47996aa9194b698e4aa070035f91f3
msgid "http://toutpt.wordpress.com/2009/03/14/plone-and-local-roles-too-quiet/"
msgstr ""

#: ../../security/permission_lists.rst:3
# 3bc7ac0ff5014eea87b5043a3aa17612
msgid "Available permissions in Plone"
msgstr ""

#: ../../security/permission_lists.rst:7
# 92424d94f97b478ab1c8bd7844b396ae
msgid "What Zope security permissions you have available for your Plone coding"
msgstr ""

#: ../../security/permission_lists.rst:0
#: ../../security/sandboxing.rst:0
# a72a9e61cab84798bafd27e68e51fc83
# 3c1ac59ae5fd44789342b9e872f9c5ce
msgid "local"
msgstr ""

#: ../../security/permission_lists.rst:12
# 49a19d3a6ec643968cb0ee894286d814
msgid "Listing different available permissions"
msgstr ""

#: ../../security/permission_lists.rst:14
# 681b1dd366af49ac8aa5fbc377f526cc
msgid "Each permission name is a string."
msgstr ""

#: ../../security/permission_lists.rst:16
# d1e269b0b69943b59252bf31427cbdbf
msgid "To see available permissions, click Security tab at your site root in Zope Management Interface."
msgstr ""

#: ../../security/permission_lists.rst:18
# c1f58420d4554498addae4ad3a8f748d
msgid "In programming, use pseudoconstants instead of permission string values:"
msgstr ""

#: ../../security/permission_lists.rst:20
# 3e7126b3b1e9497ca090aa50fd4bb2d6
msgid "See `CMFCore.permissions <http://svn.zope.org/Products.CMFCore/trunk/Products/CMFCore/permissions.py?rev=94487&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:22
# e7fc1994a3174e529e82ea5e4c774637
msgid "See `AccessControl.Permissions <http://svn.zope.org/Zope/trunk/src/AccessControl/Permissions.py?rev=96262&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:24
# 9e1fb66fa8144a13aea31103a05a034b
msgid "For available ZCML permission mappings see:"
msgstr ""

#: ../../security/permission_lists.rst:26
# 40a14f0ee4d74a7faa93f20e2cb15746
msgid "`Products/Five/permissions.zcml <http://svn.zope.org/Zope/trunk/src/Products/Five/permissions.zcml?rev=99146&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:28
# 345ed242312f47c4b4b71f51ffba0498
msgid "Permissions such as ``cmf.ModifyPortalContent``, ``zope2.View``"
msgstr ""

#: ../../security/permission_lists.rst:30
# 8acb39f2376b4c18bd847943e6006eac
msgid "`zope/security/permissions.zcml <http://svn.zope.org/zope.security/trunk/src/zope/security/permissions.zcml?rev=97988&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:32
# c2ce6c592235439688a828cbf52e1018
msgid "``zope.Public``"
msgstr ""

#: ../../security/permission_lists.rst:34
# f172791f9fc64d57a5410bc4839c4e47
msgid "or search for the string ``<permission`` in ``*.zcml`` files in the *eggs* folder of your Plone development deployment."
msgstr ""

#: ../../security/permission_lists.rst:37
# 475b970d71b349f49dc9f3bce471dbde
msgid "Example using UNIX grep tool:"
msgstr ""

#: ../../security/permission_lists.rst:44
# 18b6300cf7f74cccae711e93b5550446
msgid "Useful permissions"
msgstr ""

#: ../../security/permission_lists.rst:46
# c52a1ba025614793aedffef05a5be990
msgid "Permissions are shown by their verbose name in the :term:`ZMI`."
msgstr ""

#: ../../security/permission_lists.rst:48
# b4aee70e0bab468199dc80c4268068be
msgid "``View``"
msgstr ""

#: ../../security/permission_lists.rst:49
# b1efd750db7846f9bdcf51e5f6ff8da6
msgid "This governs whether you are allowed to view some content."
msgstr ""

#: ../../security/permission_lists.rst:53
# 5298d31d3c6d405b9354ca13191ecfa4
msgid "``Access Contents Information``"
msgstr ""

#: ../../security/permission_lists.rst:51
# 0b3fdfab09fb4bb5973061553245ab6b
msgid "This permission allows access to an object, without necessarily viewing the object. For example, a user may want to see the object's title in a list of results, even though the user can't view the contents of that file."
msgstr ""

#: ../../security/permission_lists.rst:56
# 797fd6290dda467095b35140cba123e6
msgid "``List folder contents``"
msgstr ""

#: ../../security/permission_lists.rst:56
# a7fced258028409dbc16bd9130b85249
msgid "This governs whether you can get a listing of the contents of a folder; it doesn't check whether you have the right to view the objects listed."
msgstr ""

#: ../../security/permission_lists.rst:58
# 496ee01192d9425bad05517f303a82aa
msgid "``Modify Portal Content``"
msgstr ""

#: ../../security/permission_lists.rst:59
# 39b65ab76daa42049ed7b1dda4154da9
msgid "This governs whether you are allowed to modify some content."
msgstr ""

#: ../../security/permission_lists.rst:63
# 75f18dc685044dd6a7d2593f6e0e8a8a
msgid "``Manage Portal``"
msgstr ""

#: ../../security/permission_lists.rst:61
# e4239081b09a4e9c9cacb18349496de3
msgid "This permission allows you to manage the portal. A number of views in the plone control panel are protected with this view. If you plan to write a reusable product, be very hesitant to use this permission, check whether a custom permission might make more sense."
msgstr ""

#: ../../security/permission_lists.rst:65
# 683d8688e8a54790b879e1b5d0d3098a
msgid "There is no single permission for adding content. Every content type has its own permission. If you create your own content type, create a custom add permission for it."
msgstr ""

#: ../../security/permission_lists.rst:0
#: ../../security/permissions.rst:3
# fc527d31463846b1915410555e6e6d4c
# fd5d63e724b0444e8e617cdf14e32f3f
msgid "Permissions"
msgstr ""

#: ../../security/permission_lists.rst:71
# f23eabf934e84743bdc4afcd66976df3
msgid "Permission name"
msgstr ""

#: ../../security/permission_lists.rst:71
# 1cc7205b29bb415492eaec80fbc2183f
msgid "Permission name for ZCML"
msgstr ""

#: ../../security/permission_lists.rst:73
# 6d870b3944954869a518d6748b4eb4e9
msgid "View"
msgstr ""

#: ../../security/permission_lists.rst:73
# e1f44d7e74c840b5aa0a0baa6ab40b48
msgid "zope2.View"
msgstr ""

#: ../../security/permission_lists.rst:74
# bd580264d74d481d8b05746ae5748052
msgid "Access contents information"
msgstr ""

#: ../../security/permission_lists.rst:74
# 0e477619dc0841e796778ada611d8556
msgid "zope2.AccessContentsInformation"
msgstr ""

#: ../../security/permission_lists.rst:75
# f5e36b5b7aa945678923a35adef0e8bd
msgid "List folder contents"
msgstr ""

#: ../../security/permission_lists.rst:75
# 9954924325494d20b801a1e460bd482c
msgid "cmf.ListFolderContents"
msgstr ""

#: ../../security/permission_lists.rst:76
# 3cbb40776d3347c5a9bf25fab4f2f500
msgid "Modify portal content"
msgstr ""

#: ../../security/permission_lists.rst:76
# 3b4a73d77da042a7b08426cd37f07e02
msgid "cmf.ModifyPortalContent"
msgstr ""

#: ../../security/permission_lists.rst:77
# 28543aafca364f709cd898e3c24ff356
msgid "Manage portal"
msgstr ""

#: ../../security/permission_lists.rst:77
# 0549f70be0504e9596d44dcc242e0963
msgid "cmf.ManagePortal"
msgstr ""

#: ../../security/permission_lists.rst:80
# b519c0f536044a8f9a27770acebe95d4
msgid "To reference a permission in code, you need the name as a string. Using strings is a bad convention, all common permissions have a constant in Products.CMFCore.permissions. So to perform a permission check propery, you do something like this::"
msgstr ""

#: ../../security/permission_lists.rst:91
# bdc634834e1c4e0886734a755fd25f72
msgid "All standard permissions from above can be referenced by their Permission name without spaces."
msgstr ""

#: ../../security/permission_lists.rst:93
# 0424c29621da4c78aac9d69d819715b3
msgid "More info:"
msgstr ""

#: ../../security/permission_lists.rst:95
# eea97d28018a4dc2a0a8daa45cbb417a
msgid "http://markmail.org/thread/3izsoh2ligthfcou"
msgstr ""

#: ../../security/permissions.rst:7
# 030a638285d44bba8b89a554d4483598
msgid "How to deal with permissions making your code permission-aware in Plone"
msgstr ""

#: ../../security/permissions.rst:14
# b84fbd95262d4f6ab49f8f7dfad2ca1a
msgid "Permissions control whether logged-in or anonymous users can execute code and access content."
msgstr ""

#: ../../security/permissions.rst:17
# af19d62c4958411493cac63c915ac7fd
msgid "Permissions in Plone are managed by `Zope's AccessControl module <http://svn.zope.org/AccessControl/trunk/src/AccessControl/>`_. Persistent permission setting and getting by role heavy lifting is done by `AccessControl.rolemanager.RoleManager <http://svn.zope.org/AccessControl/trunk/src/AccessControl/rolemanager.py?view=auto>`_."
msgstr ""

#: ../../security/permissions.rst:22
# 9bf19125f0984043bb7e0b88931a2565
msgid "Permission checks are done for:"
msgstr ""

#: ../../security/permissions.rst:24
# b7249edad0d94e819970bc2c8de99d60
msgid "every view/method which is hit by incoming HTTP request (Plone automatically publishes traversable methods over HTTP);"
msgstr ""

#: ../../security/permissions.rst:27
# 1426365fe6d747bd97e212474beee62f
msgid "every called method for :doc:`RestrictedPython scripts </security/sandboxing>`."
msgstr ""

#: ../../security/permissions.rst:30
# 46b286e5c0b34cfc927a59c5b6f07edd
msgid "The basic way of dealing with permissions is setting the ``permission`` attribute of view declaration. For more information see :doc:`views </views/browserviews>`."
msgstr ""

#: ../../security/permissions.rst:35
# 5addc5708d8f4742983ebf34e519cf37
msgid "Debugging permission errors: Verbose Security"
msgstr ""

#: ../../security/permissions.rst:37
# 0c1471ca780e4e5d9365b42f4fa9b515
msgid "You can turn on ``verbose-security`` option in buildout to get better traceback info when you encounter a permission problem on the site (you are presented a login dialog)."
msgstr ""

#: ../../security/permissions.rst:40
# ad7558a68af0429988087fb8ac91dbb1
msgid "For the security reasons, this option is disabled by default."
msgstr ""

#: ../../security/permissions.rst:42
# 57c99d1edf8b4da4ac3d9c6f74f62d74
msgid "Set ``verbose-security = on`` in your buildout.cfg ``instance`` or related section."
msgstr ""

#: ../../security/permissions.rst:44
# 37354c84034c4795a586ed23afe1ffb8
msgid "Rerun buildout"
msgstr ""

#: ../../security/permissions.rst:46
# 699fc4ff48af479e86657ec407ce620b
msgid "Restart Plone properly after buildout ``bin/plonectl stop && bin/plonectl start``"
msgstr ""

#: ../../security/permissions.rst:48
# c8c2242819e741af92a96aa9d07363bb
msgid "More info"
msgstr ""

#: ../../security/permissions.rst:50
# bc64167c4595411d8bd71e47353c803f
msgid "http://pypi.python.org/pypi/plone.recipe.zope2instance"
msgstr ""

#: ../../security/permissions.rst:53
# 220bcd3d803c49ee9c2f4d9c6c964cad
msgid "Checking if the logged-in user has a permission"
msgstr ""

#: ../../security/permissions.rst:55
# c86ddfb390b743b9b87642ceabca7364
msgid "The following code checks whether the logged in user has a certain permission for some object."
msgstr ""

#: ../../security/permissions.rst:78
# 234a98002a954d3ca32d37a62a635b0f
msgid "Checking whether a specific role has a permission"
msgstr ""

#: ../../security/permissions.rst:80
# e3cec824627347ffa7cdb4f46d02b17b
msgid "The following example uses the ``rolesOfPermission()`` method to check whether the *Authenticated* role has a permission on a certain folder on the site. The weirdness of the method interface is explained by the fact that it was written for use in a :term:`ZMI` template::"
msgstr ""

#: ../../security/permissions.rst:105
# 7c9b982125e6455fb7e65a862af64177
msgid "Permission Access"
msgstr ""

#: ../../security/permissions.rst:107
# fa389ca681f4450d93370f7170731564
msgid "Objects that are manageable :term:`TTW` inherit from `RoleManager  <http://api.plone.org/CMF/1.5.4/private/AccessControl.Role.RoleManager-class.html>`_. The API provided by this class permits you to manage permissions."
msgstr ""

#: ../../security/permissions.rst:111
# fd378d107166402695e633dede0bdd50
msgid "Example: see all possible permissions::"
msgstr ""

#: ../../security/permissions.rst:119
# b0bcff13e85c458f8b953482c0c9ec16
msgid "Show the security matrix of permission::"
msgstr ""

#: ../../security/permissions.rst:142
# 5870a1f59e834cd8a60b415b114cf33b
msgid "Bypassing permission checks"
msgstr ""

#: ../../security/permissions.rst:144
# 1d8f6afda2d44516a3188f07e62b84be
msgid "The current user is defined by active security manager. During both restricted and unrestricted execution certain functions may do their own security checks (``invokeFactory``, workflow, search) to filter out results."
msgstr ""

#: ../../security/permissions.rst:150
# 9532cff2eeb64e9c9bc97b208003080a
msgid "If a function does its own security checks, there is usually a code path that will execute without security check. For example the methods below have security-aware and raw versions:"
msgstr ""

#: ../../security/permissions.rst:154
# bd7a19aa70114b16b35a3651451ca0c3
msgid "``context.restrictedTraverse()`` vs. ``context.unrestrictedTraverse()``"
msgstr ""

#: ../../security/permissions.rst:156
# cddb8a405a8d46c987a87157b590624d
msgid "``portal_catalog.searchResults()`` vs. ``portal_catalog.unrestrictedSearchResults()``"
msgstr ""

#: ../../security/permissions.rst:158
# df44da324e1644a98abc7791efb9811a
msgid "However, in certain situations you have only a security-aware code path which is blocked for the current user. You still want to execute this code path and you are sure that it does not violate your site security principles."
msgstr ""

#: ../../security/permissions.rst:163
# eddb5ddcdc6f49b9944f11b9590a2e28
msgid "Below is an example how you can call any Python function and work around the security checks by establishing a temporary ``AccessControl.SecurityManager`` with a special role."
msgstr ""

#: ../../security/permissions.rst:229
# 2ad3c24a93cb46a79f8dcd421add5911
msgid "For a more complete implementation of this technique, see:"
msgstr ""

#: ../../security/permissions.rst:231
# 0cc3c39c64ac4bbb9b4567105ca37e6b
msgid "http://github.com/ned14/Easyshop/blob/master/src/easyshop.order/easyshop/order/adapters/order_management.py"
msgstr ""

#: ../../security/permissions.rst:234
# 4f57c89691cd4b7b9fe0ec3c9d17f35d
msgid "Catching ``Unauthorized``"
msgstr ""

#: ../../security/permissions.rst:236
# eca10da6e1694352b889f21b9feb1c78
msgid "Gracefully failing when the user does not have a permission. Example::"
msgstr ""

#: ../../security/permissions.rst:248
# e1415e951d204bddb716266669c0eb53
msgid "Creating permissions"
msgstr ""

#: ../../security/permissions.rst:250
# 48f4726cee2e4cdbab6b0404a00c57fa
msgid "Permissions are created declaratively in :term:`ZCML`. Before Zope 2.12 (that is, before Plone 4), the `collective.autopermission`_ package was required to enable this, but now it is standard behaviour."
msgstr ""

#: ../../security/permissions.rst:257
# 347605fcad714c139fc5233e1f9618bb
msgid "http://n2.nabble.com/creating-and-using-your-own-permissions-in-Plone-3-tp339972p1498626.html"
msgstr ""

#: ../../security/permissions.rst:259
# 640710f0cd624a399aa01b6b8993081d
msgid "http://blog.fourdigits.nl/adding-zope-2-permissions-using-just-zcml-and-a-generic-setup-profile"
msgstr ""

#: ../../security/permissions.rst:261
# 05be3b5dad054486a38c7161fe27172e
msgid "Example:"
msgstr ""

#: ../../security/permissions.rst:285
# f66a8643ee9b42f88e469b3740528407
msgid "Now you can use the permission both as a Zope 2-style permission (``MyProduct: MyPermission``) or a Zope 3-style permission (``myproduct.mypermission``). The only disadvantage is that you can't import the permission string as a variable from a ``permissions.py`` file, as you can with permissions defined programmatically."
msgstr ""

#: ../../security/permissions.rst:292
# a23450b5d67646ec9d2fc3e1b3b1cfd4
msgid "By convention, the permission id is prefixed with the name of the package it's defined in, and uses lowercase only. You have to take care that the title matches the permission string you used in ``permissions.py`` exactly --- otherwise a different, Zope 3 only, permission is registered."
msgstr ""

#: ../../security/permissions.rst:298
# 18a2960d0cf1487da75b3684cb25d93d
msgid "Zope 3 style permissions are necessary when using Zope 3 technologies such as ``BrowserViews/formlib/z3c.form``. For example, from ``configure.zcml``:"
msgstr ""

#: ../../security/permissions.rst:322
# d82aae893a3640b49d48a778114f7e2f
msgid "Define Zope 2 permissions in Python code (old style)"
msgstr ""

#: ../../security/permissions.rst:324
# 2a0a803063014d56a62d84e294290962
msgid "If you want to protect certain actions in your product by a special permission, you most likely will want to assign this permission to a role when the product is installed. You will want to use Generic Setup's ``rolemap.xml`` to assign these permissions.  A new permission will be added to the Zope instance by calling ``setDefaultRoles`` on it."
msgstr ""

#: ../../security/permissions.rst:331
# d5632ffc231f4602b13145015b2b7574
msgid "However, at the time when Generic Setup is run, almost none of your code has actually been run, so the permission doesn't exist yet.  That's why we define the permissions in ``permissions.py``, and call this from ``__init__.py``:"
msgstr ""

#: ../../security/permissions.rst:335
# b34808007d754f06a9e42c2070c9bece
msgid "``__init__.py``::"
msgstr ""

#: ../../security/permissions.rst:339
# eaf15f67e6cd4acda85bf056e891a655
msgid "``permissions.py``::"
msgstr ""

#: ../../security/permissions.rst:350
# fe31a16c854d4c5b8ef9c46b85ee14e5
msgid "When working with permissions, always use the variable name instead of the string value.  This ensures that you can't make typos with the string value, which are hard to debug.  If you do make a typo in the variable name, you'll get an ``ImportError`` or ``NameError``."
msgstr ""

#: ../../security/permissions.rst:357
# 9e256e57641d48999a336bcd3c2b66ce
msgid "Assigning permissions to users (roles)"
msgstr ""

#: ../../security/permissions.rst:359
# 8dba243748cf443cb505bcbc58e52aac
msgid "Permissions are usually assigned to roles, which are assigned to users through the web."
msgstr ""

#: ../../security/permissions.rst:362
# 7cfc06aa6ac148558add85e5586482e1
msgid "To assign a permission to a role, use ``profiles/default/rolemap.xml``:"
msgstr ""

#: ../../security/permissions.rst:377
# 7efc53e8a14a4a64ae45b36453c2d81d
msgid "Manually fix permission problems"
msgstr ""

#: ../../security/permissions.rst:379
# 673c5294c7a74da1993db7260ebd2378
msgid "In the case you fiddle with permission and manage to lock out even the admin user you can still fix the problem from the :doc:`debug prompt </misc/commandline>`."
msgstr ""

#: ../../security/permissions.rst:383
# 1235278262f44215abda3e14e88485fd
msgid "Example debug session, restoring ``Access Contents Information`` for all users::"
msgstr ""

#: ../../security/sandboxing.rst:3
# 76360ce3d58f40f6accff7d4420eded7
msgid "Sandboxing and RestrictedPython"
msgstr ""

#: ../../security/sandboxing.rst:7
# 8c19a80072b64b529a306c85bb8379c1
msgid "Legacy Plone code uses RestrictedPython sandboxing to secure each module and class functions. This documentation tells how it happens."
msgstr ""

#: ../../security/sandboxing.rst:16
# e493658dc4e941859c3f6a072c639e76
msgid "Plone has two sandboxing modes"
msgstr ""

#: ../../security/sandboxing.rst:18
# 59db3bf8950548d0837c6168067036a7
msgid "Unrestricted: Python code is executed normally and the code can access the full Zope application server environment. This includes other site instances too. This is generally what happens when you write your own add-on and add views for it."
msgstr ""

#: ../../security/sandboxing.rst:23
# efaab1727a0342dca9c8d9ebaba69943
msgid "Restricted (RestrictedPython): scripts and evalutions are specially compiled, have limited Python language functionality and every function call is checked against the security manager. This is what happens when you try to add Python code or customize page templates through Zope Management Interface."
msgstr ""

#: ../../security/sandboxing.rst:28
# e8259d764da647f6811620ef3ac4a82a
msgid "Restricted execution is enabled only for **through-the-web** scripts and **legacy code**:"
msgstr ""

#: ../../security/sandboxing.rst:30
# b3ba04375e6b40a3a1e449291cbbd0a0
msgid "Old style TAL page templates: everything you put inside page template tal:content, tal:condition, etc. These templates are .pt templates **without** accomppaning BrowserView"
msgstr ""

#: ../../security/sandboxing.rst:34
# 218e4278146a4b56aa6d9c8eb2b09609
msgid "Script (Python) code is executed (plone_skins layer Python scripts and old style form management)"
msgstr ""

#: ../../security/sandboxing.rst:38
# bf7a04b0d209424ea140fcdeff4ab203
msgid "RestrictedPython was bad idea and mostly causes headache. Avoid through-the-web Zope scripts if possible."
msgstr ""

#: ../../security/sandboxing.rst:41
# 771045f8eebd4b00be2c863c4930547d
msgid "For further information, read"
msgstr ""

#: ../../security/sandboxing.rst:43
# e8f6fa18266a4580b984a481994fe810
msgid "http://plone.293351.n2.nabble.com/Update-was-Plone-4-Chameleon-compatibility-tp5612838p5614466.html"
msgstr ""

#: ../../security/sandboxing.rst:46
# 20c0241f3d4e4747bab772cde8dc5210
msgid "Whitelisting modules for RestrictedPython import"
msgstr ""

#: ../../security/sandboxing.rst:48
# c879255fa70e4d96ab36c25b2e05bd8a
msgid "http://plone.org/documentation/kb/using-unauthorized-modules-in-scripts"
msgstr ""

#: ../../security/sandboxing.rst:51
# 8a97bb69156247eea6c6de017f185939
msgid "Traversing special cases"
msgstr ""

#: ../../security/sandboxing.rst:53
# b6a1677bd42244dcad71c3d5949cc562
msgid "Old style Zope object traversing mechanism does not expose"
msgstr ""

#: ../../security/sandboxing.rst:55
# e0c82197e488448fbb886df40f16c376
msgid "Functions without docstring (the \"\"\" comment at the beginning of the function)"
msgstr ""

#: ../../security/sandboxing.rst:57
# ea82b024301149118df5994a3bdeb0f1
msgid "Functions whose name begins with underscore (\"_\"-character)"
msgstr ""

#: ../../security/sandboxing.rst:60
# 6c773508b7e64a748ec3a7b926958d91
msgid "Unit testing RestrictedPython code"
msgstr ""

#: ../../security/sandboxing.rst:62
# 1c634994a90346bf8d85a1d0218cb279
msgid "RestrictedPython_ code is problematic, because RestrictedPython hardening is done on Abstract Syntax Tree level and effectively means all evaluated code must be available in the source code form. This makes testing RestrictedPython code little difficult."
msgstr ""

#: ../../security/sandboxing.rst:66
# 980d797ddcba4664848e5bea705bbbab
msgid "Below are few useful unit test functions::"
msgstr ""

#: ../../security/sandboxing.rst:153
# a5eb615d0ddf4ed6a30a98182bedda3f
msgid "Other references"
msgstr ""

#: ../../security/sandboxing.rst:155
# 8f77b0ccb4f44962afc6a8ce202aefa9
msgid "`zope.security <http://pypi.python.org/pypi/zope.security>`_"
msgstr ""

#: ../../security/selinux.rst:3
# 0b278f8ef84d4abaa294bef74970dffd
msgid "Using SELinux with Plone"
msgstr ""

#: ../../security/selinux.rst:7
# 9679a39ad1924460bdc407b574da524a
msgid "Tutorial on using SELinux with Plone, using Plone 4.3 and RedHat Linux 6.3."
msgstr ""

#: ../../security/selinux.rst:14
# 4449ba22a1de452a92b0320fe29f918e
msgid "This document is a tutorial on using SELinux with Plone, using RedHat Linux 6.3 and Plone 4.3. It is applicable to any Linux distribution with small changes."
msgstr ""

#: ../../security/selinux.rst:17
# 82468e41c58c45728d682bbd414a3eec
msgid "About SELinux"
msgstr ""

#: ../../security/selinux.rst:19
# e68e7ee31ddd4bf4b73f251598d4ba5a
msgid "SELinux is a mandatory access control system, meaning that SELinux assigns security *contexts* (presented by *labels*) to system resources, and allows access only to the processes that have defined required levels of authorization to the contexts. In other words, SELinux maintains that certain *target* executables (having security contexts) can access (level of access being defined explicitly) only certain files (having again security context labels). In essence the contexts are roles, which makes SELinux a Role Based Access Control system. It should be noted that even root is usually just an ordinary user for RBAC systems, and will be contained like any other user."
msgstr ""

#: ../../security/selinux.rst:21
# 4c23ebca4d5d462fab2ef80118f234b1
msgid "The concept of contexts and labels can be slightly confusing at first. It stems from the idea of chain of trust. A system that upholds that proper authorization checks are being done is worthless if the system allows moving the protected data to a place that does not have similar authorization checks. Context labels are file system attributes, and when the file is moved around the label (representing context) moves with the file. The system is supposed to limit where the information can be moved, and the contexts can be extended beyond file system (ie. labels on rows in database systems), building complete information systems that will never hand over data to a party that is unable (or unwilling) to take care of it."
msgstr ""

#: ../../security/selinux.rst:23
# 509a161be9124c6ea007c7454b5a4569
msgid "Most SELinux policies *target* an executable, and define the contexts (usually applied with labels to files) it can access by using *type enforcement rules*. However there are also *capabilities* that control more advanced features such as the ability to execute heap or stack, setuid, fork process, bind into ports, or open TCP sockets. Most of the capabilities and macros come from reference policy, which offers policy developers ready solutions to most common problems. The reference policy shipped by Linux distributions contains ready rules for some 350 targets, including applications like most common daemons (sshd), and system services (init/systemd)."
msgstr ""

#: ../../security/selinux.rst:25
# f7718f7c80fb4568bd1ea602996fc07a
msgid "The value of SELinux is in giving administrators fine granularity of access control far beyond the usual capabilities of \\*NIX systems. This is useful especially in mitigating the impact of security vulnerabilities. The most apparent downside to SELinux is the high skill requirements. To understand most of SELinux - and to be able to maintain it effectively with 3rd party applications - requires good abstraction skills, and especially the official documentation is somewhat hard to digest. SELinux was never engineered to be easy for administrators. It was engineered to be able to implement complex security models like Bell-LaPadula and MLS."
msgstr ""

#: ../../security/selinux.rst:27
# fc92ad3024b04465bfe6a63ed42259dd
msgid "There have been several myths about SELinux being heavy (in reality it comes with ~3% overhead), or that it breaks all applications. There used to be time (years ago) when SELinux applied itself by default on everything, and if the application was not included in the shipped policies it probably failed miserably. Most of the application developers and companies got frustrated to the situation, and started recommending that SELinux should always be disabled. Things have luckily changed drastically since then. Today most SELinux implementations use what is called *targeted policy*, which means that SELinux affects only applications that have explicit policies. As a result SELinux does generally nothing to your 3rd party applications - good or bad - until you enable it. This tutorial is meant to give readers pointers on how to accomplish exactly that."
msgstr ""

#: ../../security/selinux.rst:30
# a295b8ce70ac4468bfc6a5aa354ba352
msgid "Creating new SELinux policy"
msgstr ""

#: ../../security/selinux.rst:33
# 259d5d9529e14cd6b56e1322937ea489
msgid "Prerequisities"
msgstr ""

#: ../../security/selinux.rst:35
# f80407261e764925b75fb72229e08762
msgid "root access"
msgstr ""

#: ../../security/selinux.rst:36
# a1468c5d4c7a4536904effb0af85d476
msgid "Working SELinux (*sudo sestatus* reports **ENABLED**, and **enforcing**)"
msgstr ""

#: ../../security/selinux.rst:37
# 2493371cdf04485f926dae4b5b957ddc
msgid "Preferably a system that uses *targeted policy* (see the output of previous command)"
msgstr ""

#: ../../security/selinux.rst:38
# 830052d5ba374b23b59f2406b1d789d5
msgid "SELinux policy utilities installed (policycoreutils-python policycoreutils-gui)"
msgstr ""

#: ../../security/selinux.rst:39
# 7aee2809417d4767a47923d4a6391394
msgid "The application (in this case Plone) already installed"
msgstr ""

#: ../../security/selinux.rst:42
# cf87fade356c4b5ebd4e901ba2de919f
msgid "Creating new policy"
msgstr ""

#: ../../security/selinux.rst:44
# c9246fd2db924fc49192b03c5a4bbd8f
msgid "Development starts usually by generating a policy skeleton with the *sepolgen* (or sepolicy-generate) utility. It can generate several types of templates, which come with a set of basic access rights. There are several sepolgen versions out there, depending on the Linux distribution. The most important differences between them are in the included templates. Creating new policy is done with the following command: ::"
msgstr ""

#: ../../security/selinux.rst:48
# 5fa8ac2d6ff94809b9f3eba49fcfef6f
msgid "Where the parameters are:"
msgstr ""

#: ../../security/selinux.rst:50
# 3e80d5863c134cb39778d3bab86f8b32
msgid "**-n plone** gives the new policy name. Default is to use the name of the executable, but we want to give a more generic name in this case."
msgstr ""

#: ../../security/selinux.rst:51
# 808962bc004642759c4361602ae31497
msgid "**-t 3** elects a template (\"*normal application*\") that gives some commonly required access rights as a starting point"
msgstr ""

#: ../../security/selinux.rst:52
# 72c444c8e76243e09d458617b01d1c4c
msgid "**/usr/local/Plone/zinstance/bin/plonectl** is the application that will get a new context (*plonectl_exec_t*), which will get most of the type enforcement rules."
msgstr ""

#: ../../security/selinux.rst:54
# efeec85f8e32496486e92a2fbcff9f5c
msgid "The outcoming result will be four files:"
msgstr ""

#: ../../security/selinux.rst:56
# feaddb44cce845cb85af4e5bbaea7056
msgid "**plone.te** Type enforcement file defining the access rules. **This file contains most of the policy, and most of the rules go there.**"
msgstr ""

#: ../../security/selinux.rst:57
# 54d7e0f243b44614b1f3663598af7190
msgid "**plone.if** Interface file defining what *other* policies can import from your policy."
msgstr ""

#: ../../security/selinux.rst:58
# a639a3883c7f41f1aab90f53b4c35ea3
msgid "**plone.fc** File contexts file defining what context labels will be applied to files and directories."
msgstr ""

#: ../../security/selinux.rst:59
# bce5ef46113e46768974f477d22f9aca
msgid "**plone.sh** Setup script that will compile and install the policy to the system configuration (both running and persistent)."
msgstr ""

#: ../../security/selinux.rst:62
# adb7185bf29e41bb8c18842d8a20c13d
msgid "Labeling files"
msgstr ""

#: ../../security/selinux.rst:64
# 02b1a387535a4b51a37e7b99f41ca9da
msgid "Before the actual development will start file context labeling rules should be defined in **plone.fc**. You probably need some context (*plone_t*) for all files related to Plone, context (*plone_rw_t*) with write rights to *var* and the plonectl will need a context (*plonectl_exec_t*) that comes with special rights. ::"
msgstr ""

#: ../../security/selinux.rst:70
# 9bcb1acf9dad40a384323608d3c9227e
msgid "The generated **plone.te** already tells SELinux what *plone_t* and *plone_exec_t* are - valid file context types. The tools labeling files will know what to do about them. However the *plone_rw_t* is must be introduced before continuing, and the plone_t should be renamed to *plonectl_t* (to describe the target better - important for managing more complex rules): ::"
msgstr ""

#: ../../security/selinux.rst:77
# 7d85af3b69ff4870969bbf5628282826
msgid "It is also a good idea to edit the restorecon commands at the end of **plone.sh** to point to /usr/local/Plone and relabel all the files when the policy is recompiled and installed: ::"
msgstr ""

#: ../../security/selinux.rst:82
# 84d612c51d534c9792f176ae6d905e49
msgid "Development process"
msgstr ""

#: ../../security/selinux.rst:84
# 80145fe7a8f345d7ada8fcfceb1499ae
msgid "The basic policy development process for SELinux policies follows the following pattern:"
msgstr ""

#: ../../security/selinux.rst:86
# 3a37020262ca40d9bfd3a5da47efac39
msgid "Add permissive rules"
msgstr ""

#: ../../security/selinux.rst:87
# 6ecb338e89ff4a54a32ced50d0bae369
msgid "Compile & install your policy"
msgstr ""

#: ../../security/selinux.rst:88
# ee26df0b08f64c6185c97604bd26a160
msgid "Clear the audit logs"
msgstr ""

#: ../../security/selinux.rst:89
# 6cb22463e33d497fba67d01c15e92234
msgid "Run the application until it fails"
msgstr ""

#: ../../security/selinux.rst:90
# 3e9bd8048dd94f1bba022fd933dce298
msgid "Run audit2allow"
msgstr ""

#: ../../security/selinux.rst:91
# 28af43526a344ad491645c8cdab2c164
msgid "Study the output of audit2allow, and add more access rules to satisfy the application"
msgstr ""

#: ../../security/selinux.rst:92
# befed782611749f28dfa5c788f1f1de6
msgid "Repeat from step 2 until everything works"
msgstr ""

#: ../../security/selinux.rst:93
# 217f5d42dd914276b1cd0136685eb9f0
msgid "Remove permissive rules"
msgstr ""

#: ../../security/selinux.rst:96
# fc7c9f4c3e314da0b194ae643e372d65
msgid "Permissive rules"
msgstr ""

#: ../../security/selinux.rst:98
# 8a7a681e43114f96beeadad2f6e571c9
msgid "Most applications require largish amount of rules just to start properly. To reach a working set of rules faster you can switch your contexts to permissive mode by editing the *PlonePython.te*: ::"
msgstr ""

#: ../../security/selinux.rst:108
# 6068fda447fe4494ad60efad9f5881e6
msgid "Permissive in SELinux means that all actions by mentioned contexts will be allowed to process, and the incidents (*access vector denials*) will be only logged. This will allows to gather rules faster than going through the complete development cycle."
msgstr ""

#: ../../security/selinux.rst:111
# 2fec7cc3fa1f4446a31f346df630f14b
msgid "Please note that permissive rules have to be removed at some point, or the policy will **not** protect the application as expected."
msgstr ""

#: ../../security/selinux.rst:114
# 1103ec1c8cac46b188253e5ecd0a5386
msgid "Using audit2allow"
msgstr ""

#: ../../security/selinux.rst:116
# f7b12506f8a24f25b6d88e14da963d5f
msgid "Audit2allow can search both dmesg and the system audit logs for access vector cache denials, and build suggestions based on them. Because the output will be more understandable without extra noise, it is recommendable to clear audit log between development cycles. Since it is probably not a good idea to clear dmesg, it is suggested that you clear the system audit logs, and instruct audit2allow to use them as source, for example: ::"
msgstr ""

#: ../../security/selinux.rst:122
# 668f65e0a8474f12af6ec286e308a9a3
msgid "There are couple useful parameters for running audit2allow:"
msgstr ""

#: ../../security/selinux.rst:124
# 843eba977ca243e18abb9f658f97f945
msgid "*-r* adds requires (\"imports\" from other policies) to the output"
msgstr ""

#: ../../security/selinux.rst:125
# 1640addcc1184548b3a92ef40e088fba
msgid "*-R* makes audit2allow suggest compatible macros from other available policies. Macros contain often more lenient access rules, but they also reduce the amount of required rules. Using them will make the policy slightly more platform dependent, but easier to maintain."
msgstr ""

#: ../../security/selinux.rst:126
# d8e98b1997224bff9058906293f32674
msgid "*-i /var/log/audit/audit.log* makes only to audit logs to be evaluated for rules"
msgstr ""

#: ../../security/selinux.rst:129
# 9c5385b68c1f443b8ed6862074140973
msgid "Always when in trouble, and you suspect access vector cache denial, use audit2allow. If you can't figure out what is going on, also check out the output of *audit2why*, similar tool that produces more human readable reasons why access was denied. Beware though, audit2why is somewhat heavy."
msgstr ""

#: ../../security/selinux.rst:132
# d8c28e3d936744dc9296e4ba8d6cacb1
msgid "Example type enforcement rules"
msgstr ""

#: ../../security/selinux.rst:134
# 358a8caceb554d14990b8afc7178fc60
msgid "SELinux rules are actually quite simple. For instance the following rule tells to *allow* the process that has context *plonectl_exec_t* access to most common temporary files (*tmp_t*, defined in the reference policy), and the level of access will allow it most of the things that are usually done to files (but not all, for instance *setattr* is missing): ::"
msgstr ""

#: ../../security/selinux.rst:138
# fcab039730e94dbea1e1d20eac36a854
msgid "For the previous to be usable the *tmp_t* and *file* have to be introduced to the compiler, that will search for them from the other available policies. Type is a grouping item that will usually point to a security context (labeled files), while classes define what access types (ie. getattr) can are available for the type. The term *type enforcement rule* comes from the fact that SELinux rules define who can do what to the objects that are linked to types. ::"
msgstr ""

#: ../../security/selinux.rst:145
# a7d8489d0a8c4875b4ea3888d7ce4eff
msgid "There are also macros that will help in accomplishing more complex tasks. The following macro will give the executable right to bind to 8080/TCP: ::"
msgstr ""

#: ../../security/selinux.rst:149
# ea2c4bf2180d437b9f31fa80299b70ae
msgid "To get an idea about what items are available the `Reference policy API documentation <http://oss.tresys.com/docs/refpolicy/api/>`_ is the place go to."
msgstr ""

#: ../../security/selinux.rst:152
# ac01ca73962c4f22b49f9101f686d75f
msgid "Caveats"
msgstr ""

#: ../../security/selinux.rst:154
# 1e82293090774b498230abde901c1852
msgid "First of all, audit2allow is not a silver bullet. There are cases where your application accesses something that it does not really require for operation, for instance to scan your system for automatic configuration of services. There are also cases where it prints nothing yet the application clearly is denied access to something. That can be caused by *dontaudit* rules, which silence logging of events that could generate too much noise. In any case a healthy amount of criticism should be applied to everything audit2allow output, especially when the suggested rules would give access rights to outside application directories."
msgstr ""

#: ../../security/selinux.rst:156
# f7f6f7805e894af8b6b2f3ca6ac0f039
msgid "Misconfiguration can cause either file labeling to fail, or the application process not to get transitioned to proper executing context. If it seems that the policy is doing nothing, check that the files are labeled correctly (`ls -lFZ`), and the process is running in the correct context (`ps -efZ`)."
msgstr ""

#: ../../security/selinux.rst:158
# 838ed1b86b04479abdd6599adc18b955
msgid "Evaluating the file context rules (fules and their labels) is managed by a heurestic algorithm, which gives precedence to more specific rules by evaluating the length and precision of the path patterns. The patterns are easy for beginner to misconfigure. When suspecting that the file context rules are not getting applied correctly, always investigate `semanage fcontext -l` to see what rules match your files."
msgstr ""

#: ../../security/selinux.rst:161
# c73831ee0eb443d08da212aa1f05195c
msgid "Policies for Plone"
msgstr ""

#: ../../security/selinux.rst:163
# 0f899c5bbe0a4ad682d8922fe0ba3fbd
msgid "The following contains results of ordinary \"install, test & break, add rules, repeat from beginning\" development cycle for a basic Plone SELinux policy."
msgstr ""

#: ../../security/selinux.rst:166
# e8b861e7ffc34f59ba392ebe56272e04
msgid "Relabeling rights"
msgstr ""

#: ../../security/selinux.rst:168
# e4efe197b03c49cab060258343d373ca
msgid "By default you might not have the right to give any of new security labels to files, and *restorecon* may throw permission denied errors. To give the SELinux utilities (using the context *setfiles_t*) the right to change the security context based on the new types add the following rules: ::"
msgstr ""

#: ../../security/selinux.rst:191
# 901154575bc949d8b125728a389c9ec5
msgid "If the transition is not done, the application will keep running in the starting user's original context. Most likely that will be unconfined_t, which means no SELinux restrictions will be applied to the process."
msgstr ""

#: ../../security/selinux.rst:194
# ce6eda0504a341fd969f1e1569e482bc
msgid "Transition to context"
msgstr ""

#: ../../security/selinux.rst:196
# 52d90c72dbb2421e92d255f1606fa912
msgid "When you first run Plone (ie. \"plonectl fg\"), you will notice that it doesn't run, complaining about bad interpreter. Audit2allow will instruct to give rights to your uncontained_t context to run the python interpreter. This is however wrong. You wish to first instruct SELinux to change the process always to the new context (*plonectl_exec_t*) when the application is run. You also wish to have the necessary rights to execute the application so that the context transition can start: ::"
msgstr ""

#: ../../security/selinux.rst:214
# 2d116df973a34582bf4afb350d7bcf59
msgid "Later when enough rules are in place for the application to run take a look at the process context to see that the transitioning to *plonectl_exec_t* works: ::"
msgstr ""

#: ../../security/selinux.rst:221
# 5c1b4f5b8a7642598840ac96ffd0e2fb
msgid "Common process requirements"
msgstr ""

#: ../../security/selinux.rst:223
# 317db05ba7df424bbeccd690b950380f
msgid "In order for any \\*NIX process to work some basic requirements must be met. Applications require for instance access to /dev/null, and PTYs: ::"
msgstr ""

#: ../../security/selinux.rst:234
# 442348a0dd924398bd0b8316fc11056e
msgid "Zope/PLONE"
msgstr ""

#: ../../security/selinux.rst:236
# f568018ef1044fa2b0ffff7422b4ed3b
msgid "After running the plonectl commands (fg, start, stop) several times, and adding the required rules you should end up with something like following. First you will have a large amount of require stanzas for the rule compiler, and then an intermediate amount of rules: ::"
msgstr ""

#: ../../security/selinux.rst:278
# d616129330394d9aac411e6324d77892
msgid "Gathering the previous audit2allow failed completely to report tcp_socket read and write. Some system policy had probably introduced a *dontaudit* rule, which quiesced the logging for that access vector denial. Luckily Plone threw out very distinct Exception, which made resolving the issue easy."
msgstr ""

#: ../../security/selinux.rst:281
# ab315424320440ab94efe3c3b4b6299b
msgid "ZEO"
msgstr ""

#: ../../security/selinux.rst:283
# d7bd9093762a46309763c86673a9b970
msgid "There are couple differences between standalone and ZEO installations. To support both a boolean is probably good way to go. Booleans can be managed like: ::"
msgstr ""

#: ../../security/selinux.rst:290
# 29499c46e36e413588a35fc65098b092
msgid "Installing Plone in ZEO mode will change the directory *zinstance* to *zeocluster*. It is alright to either have both defined in **plone.fc**, or to use regexp: ::"
msgstr ""

#: ../../security/selinux.rst:296
# 79f127e5081644718f62af4c62cd16e0
msgid "The differences to type enforcement policy consist mostly of more networking abilities (which one probably should not allow unless really required), and the ability to run shells (ie. bash): ::"
msgstr ""

#: ../../security/selinux.rst:316
# 946513678fc54f5c933abff7e3baebeb
msgid "Maintenance utilities"
msgstr ""

#: ../../security/selinux.rst:318
# fc265b83b971498da35639aa1a77527b
msgid "The procedure for allowing maintenance utilities like *buildout* to work is quite straight forward. First introduce a new context: ::"
msgstr ""

#: ../../security/selinux.rst:323
# c986e18e2101487188c5a3451a6693de
msgid "Then label the maintenance utilities using the context: ::"
msgstr ""

#: ../../security/selinux.rst:327
# 73aea509f13f4b6c86d901628251fe56
msgid "Last, provide the necessary rules for relabeling, context transition, and for the process to run without any restrictions: ::"
msgstr ""

#: ../../security/selinux.rst:338
# ec878366e62e41fc8e9deb6ddb6831f1
msgid "After running maintenance tasks you should make sure the files have still correct labels by running something like: ::"
msgstr ""

#: ../../security/selinux.rst:343
# 0b277c0fdaf74f41a8557507370d151c
msgid "See also \"setenforce Permissive\", which will disable enforcing SELinux rules temporarily system wide."
msgstr ""

#: ../../security/selinux.rst:346
# 522461defceb497b9b92ef0a035f0322
msgid "Testing the policy"
msgstr ""

#: ../../security/selinux.rst:348
# 5851ee8ba4b14b8a95100f3db1beb6c4
msgid "Easiest way to test the policy is to label for instance the Python executable as plone_exec_t by using *chcon*, and to test the policy using Python scripts. For example: ::"
msgstr ""

#: ../../security/selinux.rst:369
# e50c4ea087474f29b2349b90298729ca
msgid "This can easily be refined into automated testing. Other forms such as Portlet inside running Plone process can also be used for testing."
msgstr ""

#: ../../security/selinux.rst:372
# 0b58900b1ced45d68532cc1513fd29dd
msgid "Deploying the policy"
msgstr ""

#: ../../security/selinux.rst:374
# 65f22a5f367245ca8ad36ce590d23c98
msgid "SELinux policies can be installed simply by running *semodule -n -i <compiled_policy.pp>*. In case packaging is required (for rolling out Plone instances automatically, or for use with centralized management tools like Satellite) it is easy to accomplish with rpm. In order to do that first install the rpm building tools: ::"
msgstr ""

#: ../../security/selinux.rst:378
# 5195ed916fd74ce2b26c3e0eb7edd794
msgid "Then modify the following RPM spec file to suit your needs: ::"
msgstr ""

#: ../../security/selinux.rst:438
# 6feea99e613a4731a40fb17b6c5b3d83
msgid "The rpm packages will be built by running the rpmbuild: ::"
msgstr ""

#: ../../security/selinux.rst:445
# 5a0f5e4a042c43cbb54012c5fc3486c4
msgid "External resources"
msgstr ""

#: ../../security/selinux.rst:447
# edaef22c8c4f4dd0998c23bf1c79ff03
msgid "The following external resources are sorted by probable usefulness to someone who is beginning working with SELinux:"
msgstr ""

#: ../../security/selinux.rst:449
# 473b5d7fe9904f719863b38b226f9fba
msgid "`Fedora SELinux FAQ <https://docs.fedoraproject.org/en-US/Fedora/13/html/SELinux_FAQ/index.html>`_"
msgstr ""

#: ../../security/selinux.rst:450
# ec5eb93ffdd2476ea1a97955c081c480
msgid "`Reference policy API <http://oss.tresys.com/docs/refpolicy/api/>`_"
msgstr ""

#: ../../security/selinux.rst:451
# 875b999da03e4748b24723d0bc0ef7c5
msgid "`NSA - SELinux FAQ <http://www.nsa.gov/research/selinux/faqs.shtml>`_"
msgstr ""

#: ../../security/selinux.rst:452
# 34e492f48c194460b5c0568324efd3bd
msgid "`NSA - SELinux main website <http://www.nsa.gov/research/selinux/index.shtml>`_"
msgstr ""

#: ../../security/selinux.rst:453
# b070db6a4ccf4724997788c5d2d52722
msgid "`Official SELinux project wiki <http://selinuxproject.org/>`_"
msgstr ""

#: ../../security/selinux.rst:454
# b0b595e7203a4e0cb6b289d187e65b46
msgid "`Red Hat Enterprise SELinux Policy Administration (RHS429) classroom course <https://www.redhat.com/training/courses/rhs429/>`_"
msgstr ""

#: ../../security/selinux.rst:455
# 035a288d833f4f7fa68edb4862b1105c
msgid "`Tresys Open Source projects <http://www.tresys.com/open-source.php>`_ (IDE, documentation about the reference policy, and several management tools)"
msgstr ""

