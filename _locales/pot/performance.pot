# SOME DESCRIPTIVE TITLE.
# Copyright (C) Plone community and other individual contributors
# This file is distributed under the same license as the Plone Developer Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Plone Developer Documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-09 14:22+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../performance/caching.rst:3
# c008e3cb31c34ec6827830f486938516
msgid "Caching rules"
msgstr ""

#: ../../performance/caching.rst:7
#: ../../performance/decorators.rst:5
#: ../../performance/instancesthreads.rst:7
#: ../../performance/tips.rst:7
# 2258d41629454b79ae2ceae1ef4e961f
# 2771d5c04a0f4a139a7565983643802f
# 274fef46f1834d5598f6988282210802
# 8bed07ec05f44c9caeaee0b8bea78dfd
msgid "Description"
msgstr ""

#: ../../performance/caching.rst:9
# 20549b7dbce143f9837949c0dcfa7f18
msgid "How to program front end caching server (Varnish, Apache) to cache the content from Plone site and thus make it faster."
msgstr ""

#: ../../performance/caching.rst:13
#: ../../performance/decorators.rst:13
#: ../../performance/instancesthreads.rst:13
#: ../../performance/ramcache.rst:8
# 871f4aa05fd842078a45ce59817a0e77
# 3986a1fd97a545ed829dc9c1094d0d18
# a784d095f6ab44dd9a58dc0e74d895a9
# 6d47e695aa6342d0b4e4b4ab14f01136
msgid "Introduction"
msgstr ""

#: ../../performance/caching.rst:15
# 7d3090faedb54d3e89e9e4d824c38f9f
msgid "Plone caching is configured using the `plone.app.caching <http://pypi.python.org/pypi/plone.app.caching>`_ add-on. It supplies a web user interface for cache configuration and default caching rules for Plone."
msgstr ""

#: ../../performance/caching.rst:20
# 0ba5855fa0c04acf863d7ec724508ec4
msgid "Using only the web user interface, ``plone.app.caching`` is very flexible already.  This document mainly deals how you can combine ``plone.app.caching`` with your custom code."
msgstr ""

#: ../../performance/caching.rst:24
# e05e423d3c314b488242f956722d1cb4
msgid "Internally ``plone.app.caching`` uses `z3c.caching <http://pypi.python.org/pypi/z3c.caching/>`_ which defines programming level ZCML directives to create your cache rules."
msgstr ""

#: ../../performance/caching.rst:28
# 55e63e7180244ae38f10667a64ae637a
msgid "``plone.app.caching`` does both:"
msgstr ""

#: ../../performance/caching.rst:30
# 4aefe058beaf45da8326a46d633b85df
msgid "front end caching server support, and"
msgstr ""

#: ../../performance/caching.rst:32
# 4f413b8d1ad243e58bf10cde5090e8cd
msgid "in-memory cache in Zope."
msgstr ""

#: ../../performance/caching.rst:34
# f9340a8898ca448ba3275208b5d9b50e
msgid "``plone.app.caching`` also defines default rules for various Plone out-of-the-box content views and item. See:"
msgstr ""

#: ../../performance/caching.rst:37
# 574bb9f36e2f4bfd8659b9b2c9016b8f
msgid "https://github.com/plone/plone.app.caching/tree/master/plone/app/caching/caching.zcml"
msgstr ""

#: ../../performance/caching.rst:39
# 761014bb684648bea68f780a11841293
msgid "The caching operations (strong, moderate, weak) are defined in Python code itself, as they have quite tricky conditions. You can find the default operations here:"
msgstr ""

#: ../../performance/caching.rst:43
# 65af029822634981a4901d9cc2cce142
msgid "https://github.com/plone/plone.app.caching/tree/master/plone/app/caching/operations/default.py"
msgstr ""

#: ../../performance/caching.rst:47
# 2e68dc8dbb5c468b9b64d0b276343ea3
msgid "You usually don't need to override the operation classes itself. ``plone.app.caching`` provides web UI to override parameters, like timeout, for each rule, on the *Detailed settings* tab in cache control panel (Create per-ruleset parameters link)."
msgstr ""

#: ../../performance/caching.rst:54
# 48e5ccb127e64764a83f280b7b18b702
msgid "Plone 3 has its own, older, caching mechanisms."
msgstr ""

#: ../../performance/caching.rst:58
# 781df1ea8f704cacb0f0cf80807d242a
msgid "Setting per-view cache rules"
msgstr ""

#: ../../performance/caching.rst:60
# ba219c107d0c4d78a7744afe03a39126
msgid "Here is an example how you can define a cache rules for your custom view class.  In this example we want to cache our site front page in Varnish, because is is very complex, and wakes up a lot of ZODB objects. The front page is programmed using ``five.grok.View`` class, but it could be any kind of view class that Plone understands."
msgstr ""

#: ../../performance/caching.rst:66
# 26fb9fe8bd1e40dbad3b9409e9f44285
msgid "Our front page is subject to moderate changes as new content comes in, but the changes are not time critical, so we define a one hour timeout for caching the front page."
msgstr ""

#: ../../performance/caching.rst:72
# 522e7a0b8d7c4d30bf658d7d46d5bf99
msgid "Currently, setting caching rules for view classes is not supported through the web, but using ZCML or Python is the way to go."
msgstr ""

#: ../../performance/caching.rst:75
# d1fa07c224394cdd8ee15fbcbfb3e229
msgid "In our case we are also using \"a dummy cache\" which does not provide purging through Plone |---| the only way to purge the front-end proxy is to do it from the Varnish control panel.  But that is OK, because if something bad ends up being cached, it will be gone in one hour."
msgstr ""

#: ../../performance/caching.rst:80
# 57c4e119959d4db799ce75dfa5105c77
msgid "Here is our ``configure.zcml`` for our custom add-on ``browser`` package:"
msgstr ""

#: ../../performance/caching.rst:111
# b98b551ff28b43e4ac16d826f34b2855
msgid "After defining the rule and checking that the rule appears in the caching control panel, we'll:"
msgstr ""

#: ../../performance/caching.rst:114
# 09f1bb07ef5842faa945bcc822a48fde
msgid "assign *Moderate caching* operation to *Homepage*;"
msgstr ""

#: ../../performance/caching.rst:116
# 8696079fab254964be16c3c3c20c3d2e
msgid "on the *Detailed settings* tab we'll use the *Create per-ruleset* command to override timeout to be 1h instead of default 24h for *Homepage*."
msgstr ""

#: ../../performance/caching.rst:121
# d5d47e29e6984a5aaca48f130ac544b8
msgid "Do not enable the Zope RAM cache for page templates. Somehow, at some point, you will end up having some bad page HTML in Zope's internal cache and you have no idea how to clear it."
msgstr ""

#: ../../performance/caching.rst:127
# 2b6ac75c6ed24c78bfbe3295e9c7c9e8
msgid "If you are testing the rule on a local computer first, remember to re-do caching control panels in the production environment, as they are stored in the database."
msgstr ""

#: ../../performance/caching.rst:132
# 72df318d751947268662ca31eae22e5e
msgid "Testing the rule"
msgstr ""

#: ../../performance/caching.rst:134
# b2b64cf1918e4f7a9dc1426d2ac2fef5
msgid "First, we'll test the rule on our local development computer to make sure that it loads;"
msgstr ""

#: ../../performance/caching.rst:137
# cf8c09b91af747eab797a9807f95b3e8
msgid "then we'll test the rule in the production environment with Varnish to see that Varnish picks up ``Expires`` header"
msgstr ""

#: ../../performance/caching.rst:142
# 01ecc78331b64c098bccb6fab7551543
msgid "To test ``plone.app.caching`` rules you need to run the site in production mode (not in the foreground).  Otherwise ``plone.app.caching`` is disabled."
msgstr ""

#: ../../performance/caching.rst:146
# 9e88012a2c1648c38f891a9217a0413e
msgid "Here is an example showing how to test loading the page using the ``wget`` UNIX command-line utility (discard the retrieved document and print the HTTP response headers)::"
msgstr ""

#: ../../performance/caching.rst:152
# e662fd31fff944d1a61721e8d4c0ba3d
msgid "The output looks like this::"
msgstr ""

#: ../../performance/caching.rst:172
# b90bb0f3cb5a4069bda3e979cdf24de9
msgid "We see that ``X-Cache-Operation`` and ``X-Cache-Rule`` from ``plone.app.caching`` debug info are present, so we know that it is setting HTTP headers correctly, so that the front end server (Varnish) will receive the appropriate directives."
msgstr ""

#: ../../performance/caching.rst:177
# 3e81532bc0a64a8389397a4273dffcd3
msgid "After deploying the change in the production environment, we'll check Varnish is picking up the rule. We fetch the page twice: first run is *cold* (not yet cached), the second run should be cached::"
msgstr ""

#: ../../performance/caching.rst:184
# 31c29ca210f141ad86bcf191f077b497
msgid "The output::"
msgstr ""

#: ../../performance/caching.rst:207
# 02f99c134b374f18beb083f60da789ba
msgid "We'll see that you have **two** numbers on line from Varnish::"
msgstr ""

#: ../../performance/caching.rst:211
# 96bb09ef60bc41cab5904c6ebedf9a93
msgid "These are Varnish internal timestamps: when the request was pulled to the cache and when it was served. If you see only one number on subsequent requests it means that Varnish is not caching the request (because it's fetching the page from Plone every time). If you see two numbers you know it is OK (and you can feel the speed)."
msgstr ""

#: ../../performance/caching.rst:217
#: ../../performance/ramcache.rst:213
#: ../../performance/tips.rst:141
# 0472445f77ba4a678af4f671bf8f903f
# 1ea4e7e3c9504614b3f312646001cbff
# 52432905fe054d47b825c168be94a951
msgid "More info:"
msgstr ""

#: ../../performance/caching.rst:219
# 9714af65bab04017a3bab011b13b4977
msgid "http://stackoverflow.com/questions/6170962/plone-app-caching-for-front-page-only"
msgstr ""

#: ../../performance/caching.rst:222
# 0119641721b44a9382a067abb1a4bee0
msgid "Creating a \"cache forever\" view"
msgstr ""

#: ../../performance/caching.rst:224
# d72bcffcd47942d1ac98f82ca892e19d
msgid "You might create views which generate or produce resources (images, JS, CSS) in-fly. If you refer this views always through content unique URL you can cache the view result forever."
msgstr ""

#: ../../performance/caching.rst:228
# e2eaa358f37d461c94d4c0b3e27b8d1b
msgid "This can be done"
msgstr ""

#: ../../performance/caching.rst:230
# 7f47d0f525bb4d6baa4d4ab2a6b33689
msgid "Using blob._p_mtime, or similar, to get the modified timestamp of the related content item. All persistent ZODB objects have _p_mtime"
msgstr ""

#: ../../performance/caching.rst:233
# fd5bcf1ca74c436eae98838099ff4ac9
msgid "Setting *plone.stableResource* ruleset on the view"
msgstr ""

#: ../../performance/caching.rst:235
# f10235f92b76450c8ac32d85a7449c20
msgid "Related ZCML"
msgstr ""

#: ../../performance/caching.rst:261
# fa47092ddf92478f8a2c24017d547c1e
msgid "Related view code::"
msgstr ""

#: ../../performance/caching.rst:298
# 3189fcd6a7214e6e9dc5ce324fea6aa1
msgid "When we refer to the view in ``<img src>`` we use modified time parameter::"
msgstr ""

#: ../../performance/decorators.rst:3
# 6fa99c0f8eeb4d0787be063c4d25b999
msgid "Cache decorators"
msgstr ""

#: ../../performance/decorators.rst:7
# 49a8698e7273416b84798438b663e0b1
msgid "How to use the Python decorator pattern to cache the result values of your computationally expensive method calls."
msgstr ""

#: ../../performance/decorators.rst:15
# 63fa0d9ab4d1460e92eef7fb44b3f277
msgid "Cache decorators are convenient methods caching of function return values."
msgstr ""

#: ../../performance/decorators.rst:17
# 3d6f0696954941e0948d8001bd2df047
msgid "Use them like this::"
msgstr ""

#: ../../performance/decorators.rst:26
# f5bfa61f0b594c59bb2dd90c549b4652
msgid "Cache decorators do not work with methods or functions that use generators (``yield``). The cache will end up storing an empty value."
msgstr ""

#: ../../performance/decorators.rst:30
# 37e9bd5669044f1f957caef0cf027dee
msgid "The `plone.memoize <http://pypi.python.org/pypi/plone.memoize>`_ package offers helpful function decorators to cache return values."
msgstr ""

#: ../../performance/decorators.rst:33
# d1d910f83355499d8cd4cea7d9615734
msgid "See also :doc:`using memcached backend for memoizers </performance/ramcache>`."
msgstr ""

#: ../../performance/decorators.rst:36
# 45993a5c84344dc3bcc0a71cdba35521
msgid "Cache result for process lifecycle"
msgstr ""

#: ../../performance/decorators.rst:38
#: ../../performance/decorators.rst:116
#: ../../performance/ramcache.rst:55
# 91b0ffc98d58412893c32d033c09ce89
# 8976488a3b75472ca935799e381e0708
# d50c4c07142c4f77bec11d753c325887
msgid "Example::"
msgstr ""

#: ../../performance/decorators.rst:55
# 1b29056c3a5a4578a2e9849f17f401dd
msgid "Timeout caches"
msgstr ""

#: ../../performance/decorators.rst:57
# d3d4c8bd84f1433ba4f02cf55ca72f64
msgid "The @ram.cache decorator takes a function argument and calls it to get a value. So long as that value is unchanged, the cached result of the decorated function is returned. This makes it easy to set a timeout cache::"
msgstr ""

#: ../../performance/decorators.rst:69
# 011c45c5058542c3ad68248faa76c2b9
msgid "time.time() returns the time in seconds as a floating point number. \"//\" is Python's integer division. So, the result of ``time() // (60 * 60)`` only changes once an hour. ``args`` passed are ignored."
msgstr ""

#: ../../performance/decorators.rst:75
# 0d055c5d0e444ad58969b53662b08bc0
msgid "Caching per request"
msgstr ""

#: ../../performance/decorators.rst:77
# c840ed97eb464290af43ccd076b67081
msgid "This pattern shows how to avoid recalculating the same value repeatedly during the lifecycle of an HTTP request."
msgstr ""

#: ../../performance/decorators.rst:81
# 9b332a67c36f4853bc13b066eb29ee0c
msgid "Caching on BrowserViews"
msgstr ""

#: ../../performance/decorators.rst:83
# 67ea8c51f0f9461ca191b8d14d45f87c
msgid "This is useful if the same view/utility is going to be called many times from different places during the same HTTP request."
msgstr ""

#: ../../performance/decorators.rst:86
# 3d1b1e01bba7439ea968844bafd04f7c
msgid "The `plone.memoize.view <https://github.com/plone/plone.memoize/tree/master/plone/memoize/view.txt>`_ package provides necessary decorators for ``BrowserView``-based classes."
msgstr ""

#: ../../performance/decorators.rst:110
# 9f492c60ce8c499b971aab0548ab4bc6
msgid "Caching on Archetypes accessors"
msgstr ""

#: ../../performance/decorators.rst:112
# 753bca01f8fd4bc7ad733c6a7e7ddfbb
msgid "If you have a custom :doc:`Archetypes accessor method </content/archetypes/fields>`, you can avoid recalculating it during the request processing."
msgstr ""

#: ../../performance/decorators.rst:136
# 4c95af2331024486a23d638ca8a0119c
msgid "Caching using global HTTP request"
msgstr ""

#: ../../performance/decorators.rst:138
# 0a5abe5f8f0b41c781e65da83f965709
msgid "This example uses the `five.globalrequest package <http://pypi.python.org/pypi/five.globalrequest>`_ for caching. Values are stored on the thread-local ``HTTPRequest`` object which lasts for the transaction lifecycle::"
msgstr ""

#: ../../performance/decorators.rst:173
# 2af68c01767846c3859f63723f8776aa
msgid "Testing memoized methods inside browser views"
msgstr ""

#: ../../performance/decorators.rst:175
# 527fd7a99fd14e448faa46f5e13b9d89
msgid "While testing browser views memoized methods you could find out that calling a method multiple times inside a test could result in getting the same result over and over, no mater what the parameters are, because you have the same context and request inside the test and the result is being cached."
msgstr ""

#: ../../performance/decorators.rst:180
# e2bb167bd0e84d78a92625f60c12b78f
msgid "One approach to by-pass this is to put your code logic inside a private method while memoizing a public method with the same name that only calls the private one:"
msgstr ""

#: ../../performance/decorators.rst:203
# ef06235d5aff4bfab805e7d8c05bf9fa
msgid "In your tests you can call the private method to avoid memoization."
msgstr ""

#: ../../performance/decorators.rst:207
#: ../../performance/ramcache.rst:220
# 4bc28575b3914aa8a393580fdd0b654a
# 5278af2ae51b42d4b9f7d9c88fe451c9
msgid "Other resources"
msgstr ""

#: ../../performance/decorators.rst:209
# bfb7783f68b9457192a376599c28dcd4
msgid "`plone.memoize source code <https://github.com/plone/plone.memoize/tree/master/plone/memoize/>`_"
msgstr ""

#: ../../performance/decorators.rst:211
#: ../../performance/ramcache.rst:224
# 8fa353f007414ecf8b17ecbbe46ca3ce
# 196d9d50d4a543268f52e13116de1fc3
msgid "`zope.app.cache source code <http://svn.zope.org/zope.app.cache/trunk/src/zope/app/cache/>`_"
msgstr ""

#: ../../performance/index.rst:3
# 894873fa0d7b4c9ba11730f810a59c36
msgid "Performance and tuning"
msgstr ""

#: ../../performance/index.rst:5
# bc92100e1caa4e63a691445f8c733e89
msgid "Tips how to optimize your Plone code for maximum performance."
msgstr ""

#: ../../performance/instancesthreads.rst:3
# 4e627ed1505241e496bf0bd897597fea
msgid "About Instances and Threads, Performance and RAM consumption"
msgstr ""

#: ../../performance/instancesthreads.rst:9
# e1f6ac4ae5db4e618baee1d652e694cc
msgid "Understanding how instances-per-core, threads-per-instance and ZODB-caches are influencing performance."
msgstr ""

#: ../../performance/instancesthreads.rst:15
# f06e946d117843c6843bfe6156af4a75
msgid "In a usal production Zope/Plone setup there are some tunings possible. So you googled a bit and found that, for a certain size of site, you need more than one Zope-instance and use `HAproxy`_ or `Pound`_ to load-balance between them. Then you may ask yourself: How many instances do I need? Next you see there is value \"threads per instance\" and wonder about the different recommendations: Only one thread or two, or four? And how does it effect memory usage?"
msgstr ""

#: ../../performance/instancesthreads.rst:24
# ad4df03df62749fd861f2d71acc25010
msgid "Rule Of The Thumb"
msgstr ""

#: ../../performance/instancesthreads.rst:26
# 17ebdb30ddf64ae09c6a32b791fe091b
msgid "A good **rule-of-the-thumb** for a common setup was and still is: **two instances per core, two threads per instance, adjust the number of objects in the ZODB cache to a number that your memory is used.**"
msgstr ""

#: ../../performance/instancesthreads.rst:30
# 9bd05446caf1435285f3e2833120bdae
msgid "**But attention!** If your setup gets more complex, if you have several logged in users or only anonymous users, if you use official, fancy, specific or home-grown add-ons: This rule may not apply."
msgstr ""

#: ../../performance/instancesthreads.rst:34
# ce4c902f9e3d42878cf8de1927865e72
msgid "In this case you need to figure out yourself. It's more important to understand the mechanism behind than sticking to a rule."
msgstr ""

#: ../../performance/instancesthreads.rst:37
# efae4f51c4b844fb8bafb7ad72f96836
msgid "With recent, faster hardware and the (sometimes odd) behaviour of virtual machines (which can be very very different dependent on the kind of VM) this needs slight or major adjustment."
msgstr ""

#: ../../performance/instancesthreads.rst:42
# dfcca6f8c3c04e148704ebbea7ac2f1d
msgid "Theory"
msgstr ""

#: ../../performance/instancesthreads.rst:49
# ce240edb2ba04749ae0d7e1add9b9f78
msgid "Threads:"
msgstr ""

#: ../../performance/instancesthreads.rst:45
# 65eb54eac1874684b5dfe09717b03ebe
msgid "A Zope instance is running a pool of threads. It queues an incoming request and dispatches it to a free thread. If no thread is free the request remains in the queue and is dispatched when a thread was freed. If all threads are used by long-running request-to-response cycles this may block such simple tasks as publishing a tiny icon."
msgstr ""

#: ../../performance/instancesthreads.rst:56
# cefa093d7daa47fd8b493f4083131fa9
msgid "Database-Connection-Pool and its Cache:"
msgstr ""

#: ../../performance/instancesthreads.rst:52
# 5644a552689a4ea8b4cfa61f7a7f2d99
msgid "Once a thread runs, it requests a ZODB database connection from the connection pool. It locks the connection so no other thread can use it. The connection pool opens a new connection if all existing connections are already in use. If the request-to-response cycle is finished and the thread is freed the connection is released back to the pool."
msgstr ""

#: ../../performance/instancesthreads.rst:67
# 3290ada4a98d40a9a8cdad25d7da6956
msgid "Memory Cache:"
msgstr ""

#: ../../performance/instancesthreads.rst:59
# a86abc082b154f4090eb303ad9502dcc
msgid "Each connection has its own memory cache. The file-system cache is shared by all connections. Each cache can have the configured number of objects in memory. Having them in memory is important, because they are unpickled if loaded from the DB - and the process of unpickling is still expensive."
msgstr ""

#: ../../performance/instancesthreads.rst:64
# 0f70e800593a4e838fb225edda732aeb
msgid "An instance may never get enough load so that all available threads are used concurrently. In this case you may find in the ZMI (Zope-root -> Control_Panel -> Database -> Main DB) that there are only 2 connections, but you have 4 threads. That's because there were never 4 connections used in parallel."
msgstr ""

#: ../../performance/instancesthreads.rst:82
# a2660f87d02446b1813b94e1868494b9
msgid "Instances and memory:"
msgstr ""

#: ../../performance/instancesthreads.rst:70
# 2c64877227b840a38e7c789223840d72
msgid "An instance creates only a minimal memory usage overhead. If you have two instances with each 2 threads or one with 4 threads and all threads are used in both cases it wont make much a difference (~15-20MB overhead per instance at time of writing)."
msgstr ""

#: ../../performance/instancesthreads.rst:75
# 0432bee705cb4188bb21750d82dcca25
msgid "Now while Plone is running for some time another significant (but compared to ZODB cache low) amount of consumed RAM is used for RAM-caching inside Zope (i.e. with plone.memoize). RAM-cache is shared by all threads but not between instances. To optimize ram-caching in a multi-instance environment \"memcached\" may be used to optimize memory cache and cache-usage and reduce an instances memory footprint."
msgstr ""

#: ../../performance/instancesthreads.rst:82
# 6b423f397dba46b68c88ceeaa3b48e46
msgid "But anyway, most memory is used (in a common setup) to cache the ZODB."
msgstr ""

#: ../../performance/instancesthreads.rst:90
# 63582187e1c24ce7bef181b9cbf5a062
msgid "Python GIL - global interpreter lock:"
msgstr ""

#: ../../performance/instancesthreads.rst:85
# b34e42d80e474c76a97b1562056f267c
msgid "Well yes, the GIL is mentioned here. In a threaded environment such as Zope is it has an impact on performance. But it is low and python was optimized over the years, also Zope has a lot of I/O which reduces the GIL impact. A good and important optimization is to set the right check interval for your machine. With `jarn.checkinterval`_ there's a good and simple to use tool to test for the right value."
msgstr ""

#: ../../performance/instancesthreads.rst:93
# 1a8cccb0f53f404688b417b6aae01dae
msgid "Practice"
msgstr ""

#: ../../performance/instancesthreads.rst:95
# 9f030930b6ca4807bb51c5f181d51aa8
msgid "All theory is gray. But what does this mean for your setup if the rule-of-thumb above does not apply?"
msgstr ""

#: ../../performance/instancesthreads.rst:98
# 05703df5c1044f1dab6898f9d5576eec
msgid "Get measurements! First of all you need to check yourself what happens on your machine(s), go and learn how to use `Munin`_ (with `munin.zope`_), HAproxy (or Pound), [tool of your choice here]. After that you'll get graphs of RAM, CPU, and load and some zope related values. HAproxy or Pound may mark a node as down because all threads were blocked by long running requests, identify these requests, `collective.stats`_ helps here."
msgstr ""

#: ../../performance/instancesthreads.rst:105
# dc8c5a075c0b423b8f23ec9cb0faaa21
msgid "More instances or more threads? This question is asked often. And can not be answered without knowing more about the Plone system. We can divide it roughly into four kinds of systems:"
msgstr ""

#: ../../performance/instancesthreads.rst:109
# 689c7acd58e74415bdf1704f42873278
msgid "Only or almost logged in users,"
msgstr ""

#: ../../performance/instancesthreads.rst:110
# e07cae63d0af4ae6b8d46ed909ea7363
msgid "Only or almost only anonymous visitors,"
msgstr ""

#: ../../performance/instancesthreads.rst:111
# 354086c8cd4e4b87a379a32cad632d55
msgid "Mixed with many users and lots of hardware behind,"
msgstr ""

#: ../../performance/instancesthreads.rst:112
# 998ce5847fe245a7b8e18b2a148e3663
msgid "Mixed with few users and low-budget hardware."
msgstr ""

#: ../../performance/instancesthreads.rst:114
# 7047dedd624045ee9669475e7f697d06
msgid "If you deal with logged in users there is no easy way to cache html-pages (highly recommended anyway for all static items) in a reverse proxy cache (i.e. `Varnish`_) in front of Plone. So Zope has much more work rendering pages. To render pages, objects need to be loaded form the database. Loading is expensive. If an object is already in the DB RAM cache it decreases the time to render a page significantly. So in a setup with lots of logged in users we need to take care almost all objects are loaded already. Each thread fetches a connection from the pool, each connection has its cache. If a user now requests a page it is first logged in and zope need a bunch of objects for this from the ZODB. Also other user specific information is loaded. Then user may operate in an intranet within a specific area, so these objects also need to be loaded. If we now have i.e 1 instance with 5 threads we have up to 5 pools (5 caches). All objects of interest are loaded in worst case 5 times. If there's 1 instance with 1 thread (1 cache) data is loaded only once. But if there is only one instance with one thread a browser shooting at the web-server with lots of requests at one time fills up the request queue of the instance and may time out soon. Also a second user may want to access data at the same time, but the only thread is blocked and the CPU idles. So the best is to stick users in a load-balancer (bind it to the __ac cookie) to 1 instance with 2 threads (also this can be adjusted dependent on your setup, test it yourself). Provide as much instances as you can (memory-consumption and cpu-usage will stop you). In such a setup usage of `memcached`_ is highly encouraged."
msgstr ""

#: ../../performance/instancesthreads.rst:137
# 7d949a9584de4708bd21bd4d0a512b0a
msgid "If you have almost all anonymous users it is much easier. You can provide less instances (here rule-of-thumb 2 per core applies in most cases) and increase threads. Too many threads are not good, because of the GIL. You need to find the number yourself, it depends much on hardware. Here - w/o memcached configured - good results can be expected, because memory cache is used efficient. Increase objects per connection cache until your memory-consumption stops you and look always at your CPU usage."
msgstr ""

#: ../../performance/instancesthreads.rst:145
# 8a643dace0c144609e24a8ddb2e541fc
msgid "In large mixed environments with enough budget for hardware it is easy: Divide your environment in two, one for logged in users, one for anonymous - so above applies."
msgstr ""

#: ../../performance/instancesthreads.rst:149
# ca0636d361084bf2806dce0d2065575c
msgid "In smaller mixed environments with less hardware behind you need to find your own balance. A good way is configuring your load balancer to stick logged-in users to one or two distinct instances. If there are more users this is kind of tricky and may take some time to figure out a good setup. So this is the most difficult setup."
msgstr ""

#: ../../performance/ramcache.rst:3
# 9930f0791f25465585d5e0c212c46128
msgid "RAM cache"
msgstr ""

#: ../../performance/ramcache.rst:10
# 4d8ffdf13dc44df79da7ba6e9fac5876
msgid "The RAM cache is a Zope facility to create custom in-process caches."
msgstr ""

#: ../../performance/ramcache.rst:13
# 8f2b58ae66704d5fbfbb865535d8f29a
msgid "Using memcached backend"
msgstr ""

#: ../../performance/ramcache.rst:15
# c07bd2e044364cccaf7b665f590b4a92
msgid "By default, Zope uses an in-process memory cache. It is possible to replace this with ``memcached``."
msgstr ""

#: ../../performance/ramcache.rst:18
# 5aa4515cc83e4499bc4335de801eaf1a
msgid "Advantages:"
msgstr ""

#: ../../performance/ramcache.rst:20
# 0bc375d8e09648c2bd9e0a8bbe48d385
msgid "All front-end clients share the cache."
msgstr ""

#: ../../performance/ramcache.rst:22
# 3cdcf355a6b44095bacd5c3b5c99a4bf
msgid "Cache survives over a client restart."
msgstr ""

#: ../../performance/ramcache.rst:25
# 4423a9b54e404bcdb6637a60bcaccb3b
msgid "Memoizers"
msgstr ""

#: ../../performance/ramcache.rst:27
# 82145bd224d64ca49cc6cdc4afb707d6
msgid "Memoize's RAM cache can be replaced with a ``memcached`` backend with the following snippet."
msgstr ""

#: ../../performance/ramcache.rst:30
# e1683b2e5ca04450866732e4efbaa1a9
msgid "See the set-up for the http://plone.org/ site as an example:"
msgstr ""

#: ../../performance/ramcache.rst:32
# 88583378b31e481ba5135af07df61eaa
msgid "https://github.com/plone/Products.PloneOrg/blob/master/src/Products/PloneOrg/caching.py"
msgstr ""

#: ../../performance/ramcache.rst:35
# 58c542f9817d42e389a319bfed98abee
msgid "RAM Cache"
msgstr ""

#: ../../performance/ramcache.rst:37
# e8674e8368c548db95f7c2ed78094379
msgid "The RAM cache is used e.g. as a rendered template cache backend."
msgstr ""

#: ../../performance/ramcache.rst:39
# 706bb8ba52b44aa8b6c4959ec436e328
msgid "You can add ``MemcachedManager`` to your Zope setup, and replace the RamCache instance in the ZMI with a new instance of ``MemcachedManager`` (keep the id the same)."
msgstr ""

#: ../../performance/ramcache.rst:43
# 8f26de8ea19c46e890123c1fe0bcb2d3
msgid "http://pypi.python.org/pypi/Products.MemcachedManager"
msgstr ""

#: ../../performance/ramcache.rst:46
# ec0bc9eae0e34c428e11780b0c6c88a5
msgid "Using custom RAM cache"
msgstr ""

#: ../../performance/ramcache.rst:48
# 80645b8451fc495babd36ce75363d00d
msgid "You want to use a custom cache if you think cache size or saturation will pose problems."
msgstr ""

#: ../../performance/ramcache.rst:51
# 160789c32aa4458d837d23604984f9d4
msgid "The following advanced example shows how to enhance existing content type text and description accessors by performing HTML transformations and caching the result in a custom RAM cache."
msgstr ""

#: ../../performance/ramcache.rst:161
# 472812f57aa24356ad9bc5c66529c73c
msgid "ZCacheable"
msgstr ""

#: ../../performance/ramcache.rst:163
# 8f7fa2eb77744d11a9b570bfcfa68a94
msgid "``ZCacheable`` is an ancient Zope design pattern for caching.  It allows persistent objects that are subclasses of ``OFS.Cacheable`` to have the cache backend configured externally."
msgstr ""

#: ../../performance/ramcache.rst:167
# 5781836e0ab8481f897d019294fe87fa
msgid "The cache type (cache id) in use is stored :doc:`persistently </persistency/persistent>` per cache user object, but the cache can be created at runtime (RAM cache) or externally (``memcached``) depending on the situation."
msgstr ""

#: ../../performance/ramcache.rst:174
# b4f3019cb84c465b90316504e7e6f387
msgid "Do not use ``ZCacheable`` in new code."
msgstr ""

#: ../../performance/ramcache.rst:176
# 2694436924f64e68986d228b69dff310
msgid "It takes optional backends which must be explicitly set::"
msgstr ""

#: ../../performance/ramcache.rst:184
# ab9ad1f989cd407582dcd879387cc22a
msgid "The ``RAMCache`` above is per thread. You cannot clear this cache for all ZEO clients easily."
msgstr ""

#: ../../performance/ramcache.rst:187
# 6f275800defd4ac5a1a26513b6b11cd2
msgid "Some hints:"
msgstr ""

#: ../../performance/ramcache.rst:189
# 8a8530adaee343debc48d22a1a78f3d7
msgid "It is enabled per persistent object::"
msgstr ""

#: ../../performance/ramcache.rst:197
# 9e9674bb893246bb816d318fa43cf484
msgid "Get known cache backends::"
msgstr ""

#: ../../performance/ramcache.rst:202
# 2afeda9827f14686b839a384b0899cb2
msgid "Disabling it (persistent change)::"
msgstr ""

#: ../../performance/ramcache.rst:215
# 1ef3bd0d43a442c0bf22ef95f4633104
msgid "https://github.com/zopefoundation/Zope/blob/master/src/OFS/Cache.py"
msgstr ""

#: ../../performance/ramcache.rst:217
# 20e2534bcb944987a684ec220ceeb652
msgid "https://github.com/plone/plone.app.ldap/tree/master/plone/app/ldap/ploneldap/util.py"
msgstr ""

#: ../../performance/ramcache.rst:222
# e0ab12e67c1c4467aa43e08abe4ab56b
msgid "`plone.memoize source code <https://github.com/plone/plone.memoize/tree/master/plone/memoize/>`_."
msgstr ""

#: ../../performance/tips.rst:3
# 5b448c8ccb7044b18e908a876fac589d
msgid "Performance tips"
msgstr ""

#: ../../performance/tips.rst:9
# 231693d8eaf54553b287c726def158a8
msgid "Tips for Plone performance tuning and making your add-on product and customizations faster."
msgstr ""

#: ../../performance/tips.rst:13
# 204a578d70f5423f9b8a29c2ad84ba36
msgid "Profiling Plone"
msgstr ""

#: ../../performance/tips.rst:15
# 4c6278ab9af84178bfd212df6b7a1f88
msgid "http://pypi.python.org/pypi/collective.profiler/"
msgstr ""

#: ../../performance/tips.rst:18
# 7704cd7596b3480a89cf08c3a1a0da38
msgid "Optimizing ZEO and threads"
msgstr ""

#: ../../performance/tips.rst:20
# 0dd9df7424794e8983cc8d03bd1f59d7
msgid "For multicore systems, which basically all production systems nowadays are, you might want to optimize Python threading vs. processes. You may also tune how many Python interpreter instructions are run before doing green thread switches in the interpreter."
msgstr ""

#: ../../performance/tips.rst:25
# d73af594b32747d8bf00948b92f0d641
msgid "https://mail.zope.org/pipermail/zodb-dev/2010-December/013897.html"
msgstr ""

#: ../../performance/tips.rst:28
# 8575e90a70b24fe085acb54599ec3be0
msgid "Debugging slow threads in production"
msgstr ""

#: ../../performance/tips.rst:30
# c2105ec0724a488482d2177110054437
msgid "http://pypi.python.org/pypi/Products.LongRequestLogger"
msgstr ""

#: ../../performance/tips.rst:33
# 130f6b1131a84e7399d03af31173220c
msgid "Memcached as session storage"
msgstr ""

#: ../../performance/tips.rst:35
# c4d242fc6c044f23bd60c9f0353d6473
msgid "Storing sessions in ZEO/ZODB does not scale well, since they are very prone to raise ``ConflictErrors`` if there is considerable load on the system."
msgstr ""

#: ../../performance/tips.rst:38
# 4f5595842d6a4b22938b6c8a382aaee3
msgid "Memcached provides a more scalable session backend."
msgstr ""

#: ../../performance/tips.rst:40
# f361b7929a2a4992adbbcfcb0b8c277d
msgid "For more information, see `lovely.session add-on product <http://pypi.python.org/pypi/lovely.session/0.2.2>`_."
msgstr ""

#: ../../performance/tips.rst:44
# 576f5b755def4725a07064edefe65d02
msgid "Input/output performance of the server"
msgstr ""

#: ../../performance/tips.rst:46
# 6d387594ba88480c94b24378f653e810
msgid "http://plope.com/Members/chrism/iostat_debugging"
msgstr ""

#: ../../performance/tips.rst:48
# e00719015fc64c23864445cb2568ead0
msgid "Summary::"
msgstr ""

#: ../../performance/tips.rst:55
# cd4c4ca7221848d3ab3e5cbb0c4159fc
msgid "Tuning complex configurations"
msgstr ""

#: ../../performance/tips.rst:57
# 0bb61b56d9c446098e17a5a6edb6cc7d
msgid "http://www.lovelysystems.com/the-decathlon-of-computer-science/"
msgstr ""

#: ../../performance/tips.rst:60
# e51fc587169946c1b6787367786800af
msgid "Reducing memory usage"
msgstr ""

#: ../../performance/tips.rst:62
# a50a050ea93c47ee90620fd1db9997e1
msgid "These tips are especially critical when running Plone on low-memory virtual private server (VPS). But using the memory tips below, and some filesystem and operating system tweaks, it is also perfectly possible to run Plone on an ARM-based Android stick, or a Raspberry Pi. See http://polyester.github.io/"
msgstr ""

#: ../../performance/tips.rst:67
# 393b082747974bfab2da0940a7729b45
msgid "Disable extra languages"
msgstr ""

#: ../../performance/tips.rst:69
# 6edc2567c7854148b91800ecea451476
msgid "Add ``PTS_LANGUAGES`` to ``buildout.cfg`` to declare which .po files are loaded on the start-up::"
msgstr ""

#: ../../performance/tips.rst:77
# 1ed8fc3fc3cb4ef7abd7c54c536f97fb
msgid "Upgrade DateTime"
msgstr ""

#: ../../performance/tips.rst:79
# eb9c7777367c4d349e71cebacecf1011
msgid "DateTime 3.x and higher use significant less memory than older versions. Pinning it to 3.0.3 (4.x not tested yet) has no known side effects on all Plone 4.1.x and 4.2.x sites, but can give up to a 20-25% reduction in memory use on lower-end hardware/virtualmachines."
msgstr ""

#: ../../performance/tips.rst:84
# 13ec9182ff204459aea6c1116cf726e7
msgid "Large files"
msgstr ""

#: ../../performance/tips.rst:86
# 80055693817e435a91a3b39c5af6fd89
msgid "How to offload blob processing from Zope:"
msgstr ""

#: ../../performance/tips.rst:88
# 8648cbdf6ab44ce38ecd904ac958a5b8
msgid "http://www.slideshare.net/Jazkarta/large-files-without-the-trials"
msgstr ""

#: ../../performance/tips.rst:91
# 30b111341e8043fdaf50efbb944fcd32
msgid "LinguaPlone and multi-lingual sites"
msgstr ""

#: ../../performance/tips.rst:93
# 3e433a7a3aab4a14baa173b50c127a29
msgid "Do not use ``LanguageIndex``, and update your ``LinguaPlone`` to version 3.1."
msgstr ""

#: ../../performance/tips.rst:96
# 5ec3238335f44647b83c616258f00ca0
msgid "http://plone.293351.n2.nabble.com/Products-LinguaPlone-LanguageIndex-vs-FieldIndex-tp5554729p5554729.html"
msgstr ""

#: ../../performance/tips.rst:98
# fea7e5b8ce814da0a8f4db6e0a2cc81f
msgid "http://plone-regional-forums.221720.n2.nabble.com/New-LinguaPlone-releases-with-large-performance-improvements-td5578581.html"
msgstr ""

#: ../../performance/tips.rst:101
# b8944551c7f54a67808942df9e946068
msgid "Sessions and performance"
msgstr ""

#: ../../performance/tips.rst:103
# 8dca28bdc1724173bfdcaac515f771a6
msgid "Write transactions much worse performance-wise than read transactions."
msgstr ""

#: ../../performance/tips.rst:105
# 7f6fbd3c4b0d461fbf63a20b7b6d52b4
msgid "By default, every login is a write transaction. Also, Plone needs to update the logged-in user's session timestamp once in a while to keep the session active."
msgstr ""

#: ../../performance/tips.rst:109
# b38c2d36448540ddb129e4bb77340b72
msgid "With a high amount of users, you may start seeing many ``ConflictErrors`` (read conflicts) with ZODB."
msgstr ""

#: ../../performance/tips.rst:112
# efd51237e2e14507ae64a173b5a23bb2
msgid "There are some tricks you can use here:"
msgstr ""

#: ../../performance/tips.rst:114
# c383f2b1c05840749dc0e2d3b9066b2d
msgid "http://plone.293351.n2.nabble.com/the-mysterious-case-of-the-zope-sessions-that-shouldn-t-tp5731395p5731395.html"
msgstr ""

#: ../../performance/tips.rst:116
# d829a9cfcb2a455fa07dd1325af666ef
msgid "http://pypi.python.org/pypi/collective.beaker/"
msgstr ""

#: ../../performance/tips.rst:119
# 1287031a871646dd8be67217e7d3e96f
msgid "ZServer thread count"
msgstr ""

#: ../../performance/tips.rst:121
# 47aea27b348c4e398d13fe154784d59a
msgid "This specifies how many requests one ZEO front-end client (ZServer) can handle."
msgstr ""

#: ../../performance/tips.rst:124
# b8f792a157004067a425838fe0043438
msgid "The default set by buildout default is 2."
msgstr ""

#: ../../performance/tips.rst:126
# 78b1cb87baaa406392b80280f1d5a4f6
msgid "Adjust it::"
msgstr ""

#: ../../performance/tips.rst:133
# 2815dc0f11e14a58b524b513600278ef
msgid "Find good value by doing performance testing for your site."
msgstr ""

#: ../../performance/tips.rst:137
# 58e6e00769384430b5291e97ac5e549a
msgid "Increasing thread count is useful if your Plone site does server-to-server traffic and your Plone site needs to wait for the other end, thus blocking Zope threads."
msgstr ""

#: ../../performance/tips.rst:143
# bd2fe1e9f4bc47418493284df1bdf4de
msgid "http://pypi.python.org/pypi/plone.recipe.zope2instance"
msgstr ""

#: ../../performance/tips.rst:146
# 49ea5f2f367d402cbb544883a8c29820
msgid "XSendFile"
msgstr ""

#: ../../performance/tips.rst:148
# 4f452a09bb6141468a4d45dbe43fc836
msgid "XSendFile is an enhancement over HTTP front end proxy protocol which allows offloading of file uploads and downloads to the front end web server."
msgstr ""

#: ../../performance/tips.rst:151
# 041938df3a634cf59335a3ecffdc11de
msgid "More info for Plone support:"
msgstr ""

#: ../../performance/tips.rst:153
# 327d5be87e6d4aa5b4659232c5b803f4
msgid "https://github.com/collective/collective.xsendfile"
msgstr ""

