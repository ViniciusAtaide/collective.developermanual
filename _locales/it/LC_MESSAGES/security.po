# 
msgid ""
msgstr ""
"Project-Id-Version: Plone Developer Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-09 14:17+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../security/csrf.rst:2
msgid "Cross-Site Request Forgery (CSRF)"
msgstr ""

#: ../../security/csrf.rst:5
msgid "Plain usage"
msgstr ""

#: ../../security/csrf.rst:7
msgid "Documentation: https://github.com/plone/plone.protect/"
msgstr ""

#: ../../security/csrf.rst:10
msgid "z3c.form"
msgstr ""

#: ../../security/csrf.rst:12
msgid ""
"z3c.form does not incude csrf protection yet: "
"https://bugs.launchpad.net/z3c.form/+bug/805794"
msgstr ""

#: ../../security/custom_permissions.rst:3
msgid "Custom permissions"
msgstr ""

#: ../../security/custom_permissions.rst:5
msgid "Creating special permissions for your product"
msgstr ""

#: ../../security/custom_permissions.rst:9
msgid "Define Zope 2 permissions in python code"
msgstr ""

#: ../../security/custom_permissions.rst:11
msgid ""
"If you want to protect certain actions in your product by a special "
"permission, you most likely will want to assign this permission to a role "
"when the product is installed.  You will want to use Generic Setup's "
"rolemap.xml to assign these permissions.  A new permission will be added to "
"the Zope instance by calling setDefaultRoles on it."
msgstr ""

#: ../../security/custom_permissions.rst:17
msgid ""
"However, at the time when Generic Setup is run, almost none of your code has"
" actually been run, so the permission doesn't exist yet.  That's why we "
"define the permissions in permissions.py, and call this from __init__.py:"
msgstr ""

#: ../../security/custom_permissions.rst:40
msgid ""
"When working with permissions, always use the variable name instead of the "
"string value.  This ensures that you can't make typos with the string value,"
" which are hard to debug.  If you do make a typo in the variable name, "
"you'll get an ImportError or NameError."
msgstr ""

#: ../../security/custom_permissions.rst:47
msgid "Make the permissions available as a Zope 3 permissions"
msgstr ""

#: ../../security/custom_permissions.rst:49
msgid ""
"To use your permissions with BrowserViews/formlib/z3c.form, you need to make"
" them available available as Zope 3 permissions. This is done in ZCML using "
"a the <permission> directive. Example configure.zcml:"
msgstr ""

#: ../../security/custom_permissions.rst:65
msgid ""
"It's convention to prefix the permission id with the name of the package "
"it's defined in and use lower case only. You have to take care that the "
"title matches exactly the permission string you used in permissions.py. "
"Otherwise a different, zope 3 only, permission is registered."
msgstr ""

#: ../../security/custom_permissions.rst:71
msgid ""
"You can use the permission to e.g. protect BrowserViews. Example "
"configure.zcml:"
msgstr ""

#: ../../security/custom_permissions.rst:95
msgid "Define both Zope 2 and Zope3 permissions in one Step in ZCML"
msgstr ""

#: ../../security/custom_permissions.rst:97
msgid ""
"You can use `collective.autopermission "
"<http://pypi.python.org/pypi/collective.autopermission/1.0b1>`_ (`svn "
"repository "
"<http://svn.plone.org/svn/collective/collective.autopermission>`_) and "
"define both the Zope 2 and Zope 3 permission at once with the <permission> "
"zcml-directive. To do that install collective.autopermission. Either add "
"\"collective.autopermission\" to \"install_requires\" in setup.py or to your"
" buildout. Then include collective.autopermission's configure.zcml *before* "
"you define the permissions *and* before you use them.  "
"(collective.autopermission is not required in Zope 2.12/Plone 4 anymore!)"
msgstr ""

#: ../../security/custom_permissions.rst:131
msgid ""
"Now you can use the permission both as a Zope 2 permission *('MyProduct: "
"MyPermission')* or a Zope 3 permission *('myproduct.mypermission')*. The "
"only disadvantage is that you can't import the permissionstring as a "
"variable from permissions.py."
msgstr ""

#: ../../security/dynamic_roles.rst:3
msgid "Dynamic roles"
msgstr ""

#: ../../security/dynamic_roles.rst:8 ../../security/local_roles.rst:12
#: ../../security/permissions.rst:12 ../../security/sandboxing.rst:14
#: ../../security/selinux.rst:12
msgid "Introduction"
msgstr ""

#: ../../security/dynamic_roles.rst:10
msgid ""
"Plone core's borg.localrole package allows you to hook into role-resolving "
"code and add roles dynamically. I.e. the role on the user depends on HTTP "
"request / environment conditions and is not something set in the site "
"database."
msgstr ""

#: ../../security/dynamic_roles.rst:15
msgid "Creating a dynamic role"
msgstr ""

#: ../../security/dynamic_roles.rst:17
msgid ""
"First :doc:`create an Ploneadd-on for your coding needs "
"</getstarted/paste>`."
msgstr ""

#: ../../security/dynamic_roles.rst:19
msgid ""
"getRoles() function is called several times per request so you might want to"
" cache the result."
msgstr ""

#: ../../security/dynamic_roles.rst:22
msgid "There is a complex example below."
msgstr ""

#: ../../security/dynamic_roles.rst:24
msgid ""
"getAllRoles() is overridden to return a custom role which is not available "
"through normal security machinery. This is required because Plone/Zope "
"builds look-up tables based on the result of getAllRoles() and all possible "
"roles must appear there"
msgstr ""

#: ../../security/dynamic_roles.rst:29
msgid ""
"getRoles() is overridden to call custom getDummyRolesOnContext() which has "
"the actual logic to resolve the roles"
msgstr ""

#: ../../security/dynamic_roles.rst:32
msgid ""
"An example code checks whether the context object implements a marker "
"interface and gives the user a role based on that"
msgstr ""

#: ../../security/dynamic_roles.rst:35
msgid "Example ``localroles.py``::"
msgstr ""

#: ../../security/dynamic_roles.rst:90
msgid ""
"Custom local role implementation is made effective using ZCML adapter "
"directive in your add-ons ``configure.zcml``::"
msgstr ""

#: ../../security/dynamic_roles.rst:105
msgid ""
"If your dynamic role is not any of Plone's existing roles you need to "
":doc:`declare it with rolemap.xml </security/local_roles>`."
msgstr ""

#: ../../security/index.rst:3
msgid "Security"
msgstr ""

#: ../../security/index.rst:5
msgid "Zope provides various built-in security facilities"
msgstr ""

#: ../../security/index.rst:7
msgid "User - role - permission three layer security model"
msgstr ""

#: ../../security/index.rst:9
msgid "Security declarations in ZCML for views, adapters, etc."
msgstr ""

#: ../../security/index.rst:11
msgid "RestrictedPython to evaluate sandboxed code"
msgstr ""

#: ../../security/local_roles.rst:3
msgid "Local roles"
msgstr ""

#: ../../security/local_roles.rst:5 ../../security/permission_lists.rst:5
#: ../../security/permissions.rst:5 ../../security/sandboxing.rst:5
#: ../../security/selinux.rst:5
msgid "Description"
msgstr ""

#: ../../security/local_roles.rst:7
msgid "Creating and setting local roles of Plone members programmatically."
msgstr ""

#: ../../security/local_roles.rst:14
msgid ""
"Local roles allows user accounts to have special privileges for a folder and"
" its children."
msgstr ""

#: ../../security/local_roles.rst:17
msgid ""
"By default Plone has roles like ``Contributor``, ``Reader``, ``Editor``, "
"etc. and you can view these on the :guilabel:`Sharing` tab and in "
":term:`ZMI` :guilabel:`Security` tab."
msgstr ""

#: ../../security/local_roles.rst:21
msgid ""
"Good introduction to roles: `Basic Roles and Permissions in Plone "
"<http://www.sixfeetup.com/blog/basic-roles-and-permissions-in-plone>`_"
msgstr ""

#: ../../security/local_roles.rst:26
msgid "Creating a new role"
msgstr ""

#: ../../security/local_roles.rst:28
msgid ""
"New Plone roles can be created through the :doc:`GenericSetup rolemap.xml "
"</components/genericsetup>` file."
msgstr ""

#: ../../security/local_roles.rst:31
msgid "Example ``profiles/default/rolemap.xml``"
msgstr ""

#: ../../security/local_roles.rst:47
msgid "Adding a role to the Sharing Tab"
msgstr ""

#: ../../security/local_roles.rst:49
msgid ""
"To let the newly created role appear in the @@sharing tab, create a "
":doc:`GenericSetup sharing.xml </components/genericsetup>` file."
msgstr ""

#: ../../security/local_roles.rst:52
msgid "Example ``profiles/default/sharing.xml``"
msgstr ""

#: ../../security/local_roles.rst:66
msgid ""
"The title is the name to be shown on the sharing page. The "
"required_permission is optional. If given, the user must have this "
"permission to be allowed to manage the particular role."
msgstr ""

#: ../../security/local_roles.rst:72
msgid ""
"For Plone 3, there is the `collective.sharingroles "
"<https://pypi.python.org/pypi/collective.sharingroles>`_ addon. Since Plone "
"4, this is `merged into plone.app.workflow "
"<https://github.com/plone/plone.app.workflow/commit/f9991ca0cc3dd2b8a2c392c145f44c21996eac67>`_."
msgstr ""

#: ../../security/local_roles.rst:77
msgid "Setting local role"
msgstr ""

#: ../../security/local_roles.rst:79
msgid ""
"``manage_setLocalRoles`` is defined in `AccessControl.Role.RoleManager "
"<http://svn.zope.org/Zope/trunk/src/AccessControl/Role.py?rev=96262&view=markup>`_."
msgstr ""

#: ../../security/local_roles.rst:81 ../../security/local_roles.rst:94
#: ../../security/permissions.rst:167
msgid "Example::"
msgstr ""

#: ../../security/local_roles.rst:87
msgid "Getting local roles"
msgstr ""

#: ../../security/local_roles.rst:89
msgid ""
"The ``get_local_roles()`` method returns currently-set local roles. This "
"does not return all the *effective* roles (which may include roles acquired "
"from the parent hierarchy). ``get_local_roles_for_userid()`` returns roles "
"for a particular user as a tuple."
msgstr ""

#: ../../security/local_roles.rst:101
msgid "Deleting local roles"
msgstr ""

#: ../../security/local_roles.rst:103
msgid ""
"``manage_delLocalRoles(userids)`` takes a *list of usernames* as argument. "
"All local roles for these users will be cleared."
msgstr ""

#: ../../security/local_roles.rst:106
msgid ""
"The following example (``membrane``-specific) will reset local roles based "
"on external input ::"
msgstr ""

#: ../../security/local_roles.rst:145
msgid "Local role caching"
msgstr ""

#: ../../security/local_roles.rst:147
msgid ""
"Resolving effective local roles is a cumbersome operation, so the result is "
"cached."
msgstr ""

#: ../../security/local_roles.rst:150
msgid ""
"**Unit testers**: Local roles are cached per request. You need to clear this"
" cache after modifying an object's local roles or switching user if you want"
" to get proper readings."
msgstr ""

#: ../../security/local_roles.rst:154
msgid "Unit test example method::"
msgstr ""

#: ../../security/local_roles.rst:169
msgid "Debugging"
msgstr ""

#: ../../security/local_roles.rst:171
msgid ""
"Set your breakpoint in "
"``Products.PlonePAS.plugins.local_role.LocalRolesManager.getRolesInContext()``"
" and "
"``Products.PlonePAS.plugins.role.GroupAwareRoleManager.getRolesForPrincipal()``."
" There you see how roles for a given context are being resolved."
msgstr ""

#: ../../security/local_roles.rst:175
msgid "Check the ``acl_users.portal_role_manager`` tool via the :term:`ZMI`."
msgstr ""

#: ../../security/local_roles.rst:177
msgid ""
"Please see the `zopyx.plone.cassandra "
"<http://pypi.python.org/pypi/zopyx.plone.cassandra>`_ add-on product."
msgstr ""

#: ../../security/local_roles.rst:180
msgid "Other"
msgstr ""

#: ../../security/local_roles.rst:182
msgid ""
"http://toutpt.wordpress.com/2009/03/14/plone-and-local-roles-too-quiet/"
msgstr ""

#: ../../security/permission_lists.rst:3
msgid "Available permissions in Plone"
msgstr ""

#: ../../security/permission_lists.rst:7
msgid ""
"What Zope security permissions you have available for your Plone coding"
msgstr ""

#: ../../security/permission_lists.rst:0 ../../security/sandboxing.rst:0
msgid "local"
msgstr ""

#: ../../security/permission_lists.rst:12
msgid "Listing different available permissions"
msgstr ""

#: ../../security/permission_lists.rst:14
msgid "Each permission name is a string."
msgstr ""

#: ../../security/permission_lists.rst:16
msgid ""
"To see available permissions, click Security tab at your site root in Zope "
"Management Interface."
msgstr ""

#: ../../security/permission_lists.rst:18
msgid ""
"In programming, use pseudoconstants instead of permission string values:"
msgstr ""

#: ../../security/permission_lists.rst:20
msgid ""
"See `CMFCore.permissions "
"<http://svn.zope.org/Products.CMFCore/trunk/Products/CMFCore/permissions.py?rev=94487&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:22
msgid ""
"See `AccessControl.Permissions "
"<http://svn.zope.org/Zope/trunk/src/AccessControl/Permissions.py?rev=96262&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:24
msgid "For available ZCML permission mappings see:"
msgstr ""

#: ../../security/permission_lists.rst:26
msgid ""
"`Products/Five/permissions.zcml "
"<http://svn.zope.org/Zope/trunk/src/Products/Five/permissions.zcml?rev=99146&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:28
msgid "Permissions such as ``cmf.ModifyPortalContent``, ``zope2.View``"
msgstr ""

#: ../../security/permission_lists.rst:30
msgid ""
"`zope/security/permissions.zcml "
"<http://svn.zope.org/zope.security/trunk/src/zope/security/permissions.zcml?rev=97988&view=markup>`_"
msgstr ""

#: ../../security/permission_lists.rst:32
msgid "``zope.Public``"
msgstr ""

#: ../../security/permission_lists.rst:34
msgid ""
"or search for the string ``<permission`` in ``*.zcml`` files in the *eggs* "
"folder of your Plone development deployment."
msgstr ""

#: ../../security/permission_lists.rst:37
msgid "Example using UNIX grep tool:"
msgstr ""

#: ../../security/permission_lists.rst:44
msgid "Useful permissions"
msgstr ""

#: ../../security/permission_lists.rst:46
msgid "Permissions are shown by their verbose name in the :term:`ZMI`."
msgstr ""

#: ../../security/permission_lists.rst:48
msgid "``View``"
msgstr ""

#: ../../security/permission_lists.rst:49
msgid "This governs whether you are allowed to view some content."
msgstr ""

#: ../../security/permission_lists.rst:53
msgid "``Access Contents Information``"
msgstr ""

#: ../../security/permission_lists.rst:51
msgid ""
"This permission allows access to an object, without necessarily viewing the "
"object. For example, a user may want to see the object's title in a list of "
"results, even though the user can't view the contents of that file."
msgstr ""

#: ../../security/permission_lists.rst:56
msgid "``List folder contents``"
msgstr ""

#: ../../security/permission_lists.rst:56
msgid ""
"This governs whether you can get a listing of the contents of a folder; it "
"doesn't check whether you have the right to view the objects listed."
msgstr ""

#: ../../security/permission_lists.rst:58
msgid "``Modify Portal Content``"
msgstr ""

#: ../../security/permission_lists.rst:59
msgid "This governs whether you are allowed to modify some content."
msgstr ""

#: ../../security/permission_lists.rst:63
msgid "``Manage Portal``"
msgstr ""

#: ../../security/permission_lists.rst:61
msgid ""
"This permission allows you to manage the portal. A number of views in the "
"plone control panel are protected with this view. If you plan to write a "
"reusable product, be very hesitant to use this permission, check whether a "
"custom permission might make more sense."
msgstr ""

#: ../../security/permission_lists.rst:65
msgid ""
"There is no single permission for adding content. Every content type has its"
" own permission. If you create your own content type, create a custom add "
"permission for it."
msgstr ""

#: ../../security/permission_lists.rst:0 ../../security/permissions.rst:3
msgid "Permissions"
msgstr ""

#: ../../security/permission_lists.rst:71
msgid "Permission name"
msgstr ""

#: ../../security/permission_lists.rst:71
msgid "Permission name for ZCML"
msgstr ""

#: ../../security/permission_lists.rst:73
msgid "View"
msgstr ""

#: ../../security/permission_lists.rst:73
msgid "zope2.View"
msgstr ""

#: ../../security/permission_lists.rst:74
msgid "Access contents information"
msgstr ""

#: ../../security/permission_lists.rst:74
msgid "zope2.AccessContentsInformation"
msgstr ""

#: ../../security/permission_lists.rst:75
msgid "List folder contents"
msgstr ""

#: ../../security/permission_lists.rst:75
msgid "cmf.ListFolderContents"
msgstr ""

#: ../../security/permission_lists.rst:76
msgid "Modify portal content"
msgstr ""

#: ../../security/permission_lists.rst:76
msgid "cmf.ModifyPortalContent"
msgstr ""

#: ../../security/permission_lists.rst:77
msgid "Manage portal"
msgstr ""

#: ../../security/permission_lists.rst:77
msgid "cmf.ManagePortal"
msgstr ""

#: ../../security/permission_lists.rst:80
msgid ""
"To reference a permission in code, you need the name as a string. Using "
"strings is a bad convention, all common permissions have a constant in "
"Products.CMFCore.permissions. So to perform a permission check propery, you "
"do something like this::"
msgstr ""

#: ../../security/permission_lists.rst:91
msgid ""
"All standard permissions from above can be referenced by their Permission "
"name without spaces."
msgstr ""

#: ../../security/permission_lists.rst:93
msgid "More info:"
msgstr ""

#: ../../security/permission_lists.rst:95
msgid "http://markmail.org/thread/3izsoh2ligthfcou"
msgstr ""

#: ../../security/permissions.rst:7
msgid ""
"How to deal with permissions making your code permission-aware in Plone"
msgstr ""

#: ../../security/permissions.rst:14
msgid ""
"Permissions control whether logged-in or anonymous users can execute code "
"and access content."
msgstr ""

#: ../../security/permissions.rst:17
msgid ""
"Permissions in Plone are managed by `Zope's AccessControl module "
"<http://svn.zope.org/AccessControl/trunk/src/AccessControl/>`_. Persistent "
"permission setting and getting by role heavy lifting is done by "
"`AccessControl.rolemanager.RoleManager "
"<http://svn.zope.org/AccessControl/trunk/src/AccessControl/rolemanager.py?view=auto>`_."
msgstr ""

#: ../../security/permissions.rst:22
msgid "Permission checks are done for:"
msgstr ""

#: ../../security/permissions.rst:24
msgid ""
"every view/method which is hit by incoming HTTP request (Plone automatically"
" publishes traversable methods over HTTP);"
msgstr ""

#: ../../security/permissions.rst:27
msgid ""
"every called method for :doc:`RestrictedPython scripts "
"</security/sandboxing>`."
msgstr ""

#: ../../security/permissions.rst:30
msgid ""
"The basic way of dealing with permissions is setting the ``permission`` "
"attribute of view declaration. For more information see :doc:`views "
"</views/browserviews>`."
msgstr ""

#: ../../security/permissions.rst:35
msgid "Debugging permission errors: Verbose Security"
msgstr ""

#: ../../security/permissions.rst:37
msgid ""
"You can turn on ``verbose-security`` option in buildout to get better "
"traceback info when you encounter a permission problem on the site (you are "
"presented a login dialog)."
msgstr ""

#: ../../security/permissions.rst:40
msgid "For the security reasons, this option is disabled by default."
msgstr ""

#: ../../security/permissions.rst:42
msgid ""
"Set ``verbose-security = on`` in your buildout.cfg ``instance`` or related "
"section."
msgstr ""

#: ../../security/permissions.rst:44
msgid "Rerun buildout"
msgstr ""

#: ../../security/permissions.rst:46
msgid ""
"Restart Plone properly after buildout ``bin/plonectl stop && bin/plonectl "
"start``"
msgstr ""

#: ../../security/permissions.rst:48
msgid "More info"
msgstr ""

#: ../../security/permissions.rst:50
msgid "http://pypi.python.org/pypi/plone.recipe.zope2instance"
msgstr ""

#: ../../security/permissions.rst:53
msgid "Checking if the logged-in user has a permission"
msgstr ""

#: ../../security/permissions.rst:55
msgid ""
"The following code checks whether the logged in user has a certain "
"permission for some object."
msgstr ""

#: ../../security/permissions.rst:78
msgid "Checking whether a specific role has a permission"
msgstr ""

#: ../../security/permissions.rst:80
msgid ""
"The following example uses the ``rolesOfPermission()`` method to check "
"whether the *Authenticated* role has a permission on a certain folder on the"
" site. The weirdness of the method interface is explained by the fact that "
"it was written for use in a :term:`ZMI` template::"
msgstr ""

#: ../../security/permissions.rst:105
msgid "Permission Access"
msgstr ""

#: ../../security/permissions.rst:107
msgid ""
"Objects that are manageable :term:`TTW` inherit from `RoleManager  "
"<http://api.plone.org/CMF/1.5.4/private/AccessControl.Role.RoleManager-"
"class.html>`_. The API provided by this class permits you to manage "
"permissions."
msgstr ""

#: ../../security/permissions.rst:111
msgid "Example: see all possible permissions::"
msgstr ""

#: ../../security/permissions.rst:119
msgid "Show the security matrix of permission::"
msgstr ""

#: ../../security/permissions.rst:142
msgid "Bypassing permission checks"
msgstr ""

#: ../../security/permissions.rst:144
msgid ""
"The current user is defined by active security manager. During both "
"restricted and unrestricted execution certain functions may do their own "
"security checks (``invokeFactory``, workflow, search) to filter out results."
msgstr ""

#: ../../security/permissions.rst:150
msgid ""
"If a function does its own security checks, there is usually a code path "
"that will execute without security check. For example the methods below have"
" security-aware and raw versions:"
msgstr ""

#: ../../security/permissions.rst:154
msgid ""
"``context.restrictedTraverse()`` vs. ``context.unrestrictedTraverse()``"
msgstr ""

#: ../../security/permissions.rst:156
msgid ""
"``portal_catalog.searchResults()`` vs. "
"``portal_catalog.unrestrictedSearchResults()``"
msgstr ""

#: ../../security/permissions.rst:158
msgid ""
"However, in certain situations you have only a security-aware code path "
"which is blocked for the current user. You still want to execute this code "
"path and you are sure that it does not violate your site security "
"principles."
msgstr ""

#: ../../security/permissions.rst:163
msgid ""
"Below is an example how you can call any Python function and work around the"
" security checks by establishing a temporary "
"``AccessControl.SecurityManager`` with a special role."
msgstr ""

#: ../../security/permissions.rst:229
msgid "For a more complete implementation of this technique, see:"
msgstr ""

#: ../../security/permissions.rst:231
msgid ""
"http://github.com/ned14/Easyshop/blob/master/src/easyshop.order/easyshop/order/adapters/order_management.py"
msgstr ""

#: ../../security/permissions.rst:234
msgid "Catching ``Unauthorized``"
msgstr ""

#: ../../security/permissions.rst:236
msgid "Gracefully failing when the user does not have a permission. Example::"
msgstr ""

#: ../../security/permissions.rst:248
msgid "Creating permissions"
msgstr ""

#: ../../security/permissions.rst:250
msgid ""
"Permissions are created declaratively in :term:`ZCML`. Before Zope 2.12 "
"(that is, before Plone 4), the `collective.autopermission`_ package was "
"required to enable this, but now it is standard behaviour."
msgstr ""

#: ../../security/permissions.rst:257
msgid ""
"http://n2.nabble.com/creating-and-using-your-own-permissions-in-"
"Plone-3-tp339972p1498626.html"
msgstr ""

#: ../../security/permissions.rst:259
msgid ""
"http://blog.fourdigits.nl/adding-zope-2-permissions-using-just-zcml-and-a"
"-generic-setup-profile"
msgstr ""

#: ../../security/permissions.rst:261
msgid "Example:"
msgstr ""

#: ../../security/permissions.rst:285
msgid ""
"Now you can use the permission both as a Zope 2-style permission "
"(``MyProduct: MyPermission``) or a Zope 3-style permission "
"(``myproduct.mypermission``). The only disadvantage is that you can't import"
" the permission string as a variable from a ``permissions.py`` file, as you "
"can with permissions defined programmatically."
msgstr ""

#: ../../security/permissions.rst:292
msgid ""
"By convention, the permission id is prefixed with the name of the package "
"it's defined in, and uses lowercase only. You have to take care that the "
"title matches the permission string you used in ``permissions.py`` exactly "
"--- otherwise a different, Zope 3 only, permission is registered."
msgstr ""

#: ../../security/permissions.rst:298
msgid ""
"Zope 3 style permissions are necessary when using Zope 3 technologies such "
"as ``BrowserViews/formlib/z3c.form``. For example, from ``configure.zcml``:"
msgstr ""

#: ../../security/permissions.rst:322
msgid "Define Zope 2 permissions in Python code (old style)"
msgstr ""

#: ../../security/permissions.rst:324
msgid ""
"If you want to protect certain actions in your product by a special "
"permission, you most likely will want to assign this permission to a role "
"when the product is installed. You will want to use Generic Setup's "
"``rolemap.xml`` to assign these permissions.  A new permission will be added"
" to the Zope instance by calling ``setDefaultRoles`` on it."
msgstr ""

#: ../../security/permissions.rst:331
msgid ""
"However, at the time when Generic Setup is run, almost none of your code has"
" actually been run, so the permission doesn't exist yet.  That's why we "
"define the permissions in ``permissions.py``, and call this from "
"``__init__.py``:"
msgstr ""

#: ../../security/permissions.rst:335
msgid "``__init__.py``::"
msgstr ""

#: ../../security/permissions.rst:339
msgid "``permissions.py``::"
msgstr ""

#: ../../security/permissions.rst:350
msgid ""
"When working with permissions, always use the variable name instead of the "
"string value.  This ensures that you can't make typos with the string value,"
" which are hard to debug.  If you do make a typo in the variable name, "
"you'll get an ``ImportError`` or ``NameError``."
msgstr ""

#: ../../security/permissions.rst:357
msgid "Assigning permissions to users (roles)"
msgstr ""

#: ../../security/permissions.rst:359
msgid ""
"Permissions are usually assigned to roles, which are assigned to users "
"through the web."
msgstr ""

#: ../../security/permissions.rst:362
msgid ""
"To assign a permission to a role, use ``profiles/default/rolemap.xml``:"
msgstr ""

#: ../../security/permissions.rst:377
msgid "Manually fix permission problems"
msgstr ""

#: ../../security/permissions.rst:379
msgid ""
"In the case you fiddle with permission and manage to lock out even the admin"
" user you can still fix the problem from the :doc:`debug prompt "
"</misc/commandline>`."
msgstr ""

#: ../../security/permissions.rst:383
msgid ""
"Example debug session, restoring ``Access Contents Information`` for all "
"users::"
msgstr ""

#: ../../security/sandboxing.rst:3
msgid "Sandboxing and RestrictedPython"
msgstr ""

#: ../../security/sandboxing.rst:7
msgid ""
"Legacy Plone code uses RestrictedPython sandboxing to secure each module and"
" class functions. This documentation tells how it happens."
msgstr ""

#: ../../security/sandboxing.rst:16
msgid "Plone has two sandboxing modes"
msgstr ""

#: ../../security/sandboxing.rst:18
msgid ""
"Unrestricted: Python code is executed normally and the code can access the "
"full Zope application server environment. This includes other site instances"
" too. This is generally what happens when you write your own add-on and add "
"views for it."
msgstr ""

#: ../../security/sandboxing.rst:23
msgid ""
"Restricted (RestrictedPython): scripts and evalutions are specially "
"compiled, have limited Python language functionality and every function call"
" is checked against the security manager. This is what happens when you try "
"to add Python code or customize page templates through Zope Management "
"Interface."
msgstr ""

#: ../../security/sandboxing.rst:28
msgid ""
"Restricted execution is enabled only for **through-the-web** scripts and "
"**legacy code**:"
msgstr ""

#: ../../security/sandboxing.rst:30
msgid ""
"Old style TAL page templates: everything you put inside page template "
"tal:content, tal:condition, etc. These templates are .pt templates "
"**without** accomppaning BrowserView"
msgstr ""

#: ../../security/sandboxing.rst:34
msgid ""
"Script (Python) code is executed (plone_skins layer Python scripts and old "
"style form management)"
msgstr ""

#: ../../security/sandboxing.rst:38
msgid ""
"RestrictedPython was bad idea and mostly causes headache. Avoid through-the-"
"web Zope scripts if possible."
msgstr ""

#: ../../security/sandboxing.rst:41
msgid "For further information, read"
msgstr ""

#: ../../security/sandboxing.rst:43
msgid ""
"http://plone.293351.n2.nabble.com/Update-was-Plone-4-Chameleon-"
"compatibility-tp5612838p5614466.html"
msgstr ""

#: ../../security/sandboxing.rst:46
msgid "Whitelisting modules for RestrictedPython import"
msgstr ""

#: ../../security/sandboxing.rst:48
msgid ""
"http://plone.org/documentation/kb/using-unauthorized-modules-in-scripts"
msgstr ""

#: ../../security/sandboxing.rst:51
msgid "Traversing special cases"
msgstr ""

#: ../../security/sandboxing.rst:53
msgid "Old style Zope object traversing mechanism does not expose"
msgstr ""

#: ../../security/sandboxing.rst:55
msgid ""
"Functions without docstring (the \"\"\" comment at the beginning of the "
"function)"
msgstr ""

#: ../../security/sandboxing.rst:57
msgid "Functions whose name begins with underscore (\"_\"-character)"
msgstr ""

#: ../../security/sandboxing.rst:60
msgid "Unit testing RestrictedPython code"
msgstr ""

#: ../../security/sandboxing.rst:62
msgid ""
"RestrictedPython_ code is problematic, because RestrictedPython hardening is"
" done on Abstract Syntax Tree level and effectively means all evaluated code"
" must be available in the source code form. This makes testing "
"RestrictedPython code little difficult."
msgstr ""

#: ../../security/sandboxing.rst:66
msgid "Below are few useful unit test functions::"
msgstr ""

#: ../../security/sandboxing.rst:153
msgid "Other references"
msgstr ""

#: ../../security/sandboxing.rst:155
msgid "`zope.security <http://pypi.python.org/pypi/zope.security>`_"
msgstr ""

#: ../../security/selinux.rst:3
msgid "Using SELinux with Plone"
msgstr ""

#: ../../security/selinux.rst:7
msgid ""
"Tutorial on using SELinux with Plone, using Plone 4.3 and RedHat Linux 6.3."
msgstr ""

#: ../../security/selinux.rst:14
msgid ""
"This document is a tutorial on using SELinux with Plone, using RedHat Linux "
"6.3 and Plone 4.3. It is applicable to any Linux distribution with small "
"changes."
msgstr ""

#: ../../security/selinux.rst:17
msgid "About SELinux"
msgstr ""

#: ../../security/selinux.rst:19
msgid ""
"SELinux is a mandatory access control system, meaning that SELinux assigns "
"security *contexts* (presented by *labels*) to system resources, and allows "
"access only to the processes that have defined required levels of "
"authorization to the contexts. In other words, SELinux maintains that "
"certain *target* executables (having security contexts) can access (level of"
" access being defined explicitly) only certain files (having again security "
"context labels). In essence the contexts are roles, which makes SELinux a "
"Role Based Access Control system. It should be noted that even root is "
"usually just an ordinary user for RBAC systems, and will be contained like "
"any other user."
msgstr ""

#: ../../security/selinux.rst:21
msgid ""
"The concept of contexts and labels can be slightly confusing at first. It "
"stems from the idea of chain of trust. A system that upholds that proper "
"authorization checks are being done is worthless if the system allows moving"
" the protected data to a place that does not have similar authorization "
"checks. Context labels are file system attributes, and when the file is "
"moved around the label (representing context) moves with the file. The "
"system is supposed to limit where the information can be moved, and the "
"contexts can be extended beyond file system (ie. labels on rows in database "
"systems), building complete information systems that will never hand over "
"data to a party that is unable (or unwilling) to take care of it."
msgstr ""

#: ../../security/selinux.rst:23
msgid ""
"Most SELinux policies *target* an executable, and define the contexts "
"(usually applied with labels to files) it can access by using *type "
"enforcement rules*. However there are also *capabilities* that control more "
"advanced features such as the ability to execute heap or stack, setuid, fork"
" process, bind into ports, or open TCP sockets. Most of the capabilities and"
" macros come from reference policy, which offers policy developers ready "
"solutions to most common problems. The reference policy shipped by Linux "
"distributions contains ready rules for some 350 targets, including "
"applications like most common daemons (sshd), and system services "
"(init/systemd)."
msgstr ""

#: ../../security/selinux.rst:25
msgid ""
"The value of SELinux is in giving administrators fine granularity of access "
"control far beyond the usual capabilities of \\*NIX systems. This is useful "
"especially in mitigating the impact of security vulnerabilities. The most "
"apparent downside to SELinux is the high skill requirements. To understand "
"most of SELinux - and to be able to maintain it effectively with 3rd party "
"applications - requires good abstraction skills, and especially the official"
" documentation is somewhat hard to digest. SELinux was never engineered to "
"be easy for administrators. It was engineered to be able to implement "
"complex security models like Bell-LaPadula and MLS."
msgstr ""

#: ../../security/selinux.rst:27
msgid ""
"There have been several myths about SELinux being heavy (in reality it comes"
" with ~3% overhead), or that it breaks all applications. There used to be "
"time (years ago) when SELinux applied itself by default on everything, and "
"if the application was not included in the shipped policies it probably "
"failed miserably. Most of the application developers and companies got "
"frustrated to the situation, and started recommending that SELinux should "
"always be disabled. Things have luckily changed drastically since then. "
"Today most SELinux implementations use what is called *targeted policy*, "
"which means that SELinux affects only applications that have explicit "
"policies. As a result SELinux does generally nothing to your 3rd party "
"applications - good or bad - until you enable it. This tutorial is meant to "
"give readers pointers on how to accomplish exactly that."
msgstr ""

#: ../../security/selinux.rst:30
msgid "Creating new SELinux policy"
msgstr ""

#: ../../security/selinux.rst:33
msgid "Prerequisities"
msgstr ""

#: ../../security/selinux.rst:35
msgid "root access"
msgstr ""

#: ../../security/selinux.rst:36
msgid ""
"Working SELinux (*sudo sestatus* reports **ENABLED**, and **enforcing**)"
msgstr ""

#: ../../security/selinux.rst:37
msgid ""
"Preferably a system that uses *targeted policy* (see the output of previous "
"command)"
msgstr ""

#: ../../security/selinux.rst:38
msgid ""
"SELinux policy utilities installed (policycoreutils-python policycoreutils-"
"gui)"
msgstr ""

#: ../../security/selinux.rst:39
msgid "The application (in this case Plone) already installed"
msgstr ""

#: ../../security/selinux.rst:42
msgid "Creating new policy"
msgstr ""

#: ../../security/selinux.rst:44
msgid ""
"Development starts usually by generating a policy skeleton with the "
"*sepolgen* (or sepolicy-generate) utility. It can generate several types of "
"templates, which come with a set of basic access rights. There are several "
"sepolgen versions out there, depending on the Linux distribution. The most "
"important differences between them are in the included templates. Creating "
"new policy is done with the following command: ::"
msgstr ""

#: ../../security/selinux.rst:48
msgid "Where the parameters are:"
msgstr ""

#: ../../security/selinux.rst:50
msgid ""
"**-n plone** gives the new policy name. Default is to use the name of the "
"executable, but we want to give a more generic name in this case."
msgstr ""

#: ../../security/selinux.rst:51
msgid ""
"**-t 3** elects a template (\"*normal application*\") that gives some "
"commonly required access rights as a starting point"
msgstr ""

#: ../../security/selinux.rst:52
msgid ""
"**/usr/local/Plone/zinstance/bin/plonectl** is the application that will get"
" a new context (*plonectl_exec_t*), which will get most of the type "
"enforcement rules."
msgstr ""

#: ../../security/selinux.rst:54
msgid "The outcoming result will be four files:"
msgstr ""

#: ../../security/selinux.rst:56
msgid ""
"**plone.te** Type enforcement file defining the access rules. **This file "
"contains most of the policy, and most of the rules go there.**"
msgstr ""

#: ../../security/selinux.rst:57
msgid ""
"**plone.if** Interface file defining what *other* policies can import from "
"your policy."
msgstr ""

#: ../../security/selinux.rst:58
msgid ""
"**plone.fc** File contexts file defining what context labels will be applied"
" to files and directories."
msgstr ""

#: ../../security/selinux.rst:59
msgid ""
"**plone.sh** Setup script that will compile and install the policy to the "
"system configuration (both running and persistent)."
msgstr ""

#: ../../security/selinux.rst:62
msgid "Labeling files"
msgstr ""

#: ../../security/selinux.rst:64
msgid ""
"Before the actual development will start file context labeling rules should "
"be defined in **plone.fc**. You probably need some context (*plone_t*) for "
"all files related to Plone, context (*plone_rw_t*) with write rights to "
"*var* and the plonectl will need a context (*plonectl_exec_t*) that comes "
"with special rights. ::"
msgstr ""

#: ../../security/selinux.rst:70
msgid ""
"The generated **plone.te** already tells SELinux what *plone_t* and "
"*plone_exec_t* are - valid file context types. The tools labeling files will"
" know what to do about them. However the *plone_rw_t* is must be introduced "
"before continuing, and the plone_t should be renamed to *plonectl_t* (to "
"describe the target better - important for managing more complex rules): ::"
msgstr ""

#: ../../security/selinux.rst:77
msgid ""
"It is also a good idea to edit the restorecon commands at the end of "
"**plone.sh** to point to /usr/local/Plone and relabel all the files when the"
" policy is recompiled and installed: ::"
msgstr ""

#: ../../security/selinux.rst:82
msgid "Development process"
msgstr ""

#: ../../security/selinux.rst:84
msgid ""
"The basic policy development process for SELinux policies follows the "
"following pattern:"
msgstr ""

#: ../../security/selinux.rst:86
msgid "Add permissive rules"
msgstr ""

#: ../../security/selinux.rst:87
msgid "Compile & install your policy"
msgstr ""

#: ../../security/selinux.rst:88
msgid "Clear the audit logs"
msgstr ""

#: ../../security/selinux.rst:89
msgid "Run the application until it fails"
msgstr ""

#: ../../security/selinux.rst:90
msgid "Run audit2allow"
msgstr ""

#: ../../security/selinux.rst:91
msgid ""
"Study the output of audit2allow, and add more access rules to satisfy the "
"application"
msgstr ""

#: ../../security/selinux.rst:92
msgid "Repeat from step 2 until everything works"
msgstr ""

#: ../../security/selinux.rst:93
msgid "Remove permissive rules"
msgstr ""

#: ../../security/selinux.rst:96
msgid "Permissive rules"
msgstr ""

#: ../../security/selinux.rst:98
msgid ""
"Most applications require largish amount of rules just to start properly. To"
" reach a working set of rules faster you can switch your contexts to "
"permissive mode by editing the *PlonePython.te*: ::"
msgstr ""

#: ../../security/selinux.rst:108
msgid ""
"Permissive in SELinux means that all actions by mentioned contexts will be "
"allowed to process, and the incidents (*access vector denials*) will be only"
" logged. This will allows to gather rules faster than going through the "
"complete development cycle."
msgstr ""

#: ../../security/selinux.rst:111
msgid ""
"Please note that permissive rules have to be removed at some point, or the "
"policy will **not** protect the application as expected."
msgstr ""

#: ../../security/selinux.rst:114
msgid "Using audit2allow"
msgstr ""

#: ../../security/selinux.rst:116
msgid ""
"Audit2allow can search both dmesg and the system audit logs for access "
"vector cache denials, and build suggestions based on them. Because the "
"output will be more understandable without extra noise, it is recommendable "
"to clear audit log between development cycles. Since it is probably not a "
"good idea to clear dmesg, it is suggested that you clear the system audit "
"logs, and instruct audit2allow to use them as source, for example: ::"
msgstr ""

#: ../../security/selinux.rst:122
msgid "There are couple useful parameters for running audit2allow:"
msgstr ""

#: ../../security/selinux.rst:124
msgid "*-r* adds requires (\"imports\" from other policies) to the output"
msgstr ""

#: ../../security/selinux.rst:125
msgid ""
"*-R* makes audit2allow suggest compatible macros from other available "
"policies. Macros contain often more lenient access rules, but they also "
"reduce the amount of required rules. Using them will make the policy "
"slightly more platform dependent, but easier to maintain."
msgstr ""

#: ../../security/selinux.rst:126
msgid ""
"*-i /var/log/audit/audit.log* makes only to audit logs to be evaluated for "
"rules"
msgstr ""

#: ../../security/selinux.rst:129
msgid ""
"Always when in trouble, and you suspect access vector cache denial, use "
"audit2allow. If you can't figure out what is going on, also check out the "
"output of *audit2why*, similar tool that produces more human readable "
"reasons why access was denied. Beware though, audit2why is somewhat heavy."
msgstr ""

#: ../../security/selinux.rst:132
msgid "Example type enforcement rules"
msgstr ""

#: ../../security/selinux.rst:134
msgid ""
"SELinux rules are actually quite simple. For instance the following rule "
"tells to *allow* the process that has context *plonectl_exec_t* access to "
"most common temporary files (*tmp_t*, defined in the reference policy), and "
"the level of access will allow it most of the things that are usually done "
"to files (but not all, for instance *setattr* is missing): ::"
msgstr ""

#: ../../security/selinux.rst:138
msgid ""
"For the previous to be usable the *tmp_t* and *file* have to be introduced "
"to the compiler, that will search for them from the other available "
"policies. Type is a grouping item that will usually point to a security "
"context (labeled files), while classes define what access types (ie. "
"getattr) can are available for the type. The term *type enforcement rule* "
"comes from the fact that SELinux rules define who can do what to the objects"
" that are linked to types. ::"
msgstr ""

#: ../../security/selinux.rst:145
msgid ""
"There are also macros that will help in accomplishing more complex tasks. "
"The following macro will give the executable right to bind to 8080/TCP: ::"
msgstr ""

#: ../../security/selinux.rst:149
msgid ""
"To get an idea about what items are available the `Reference policy API "
"documentation <http://oss.tresys.com/docs/refpolicy/api/>`_ is the place go "
"to."
msgstr ""

#: ../../security/selinux.rst:152
msgid "Caveats"
msgstr ""

#: ../../security/selinux.rst:154
msgid ""
"First of all, audit2allow is not a silver bullet. There are cases where your"
" application accesses something that it does not really require for "
"operation, for instance to scan your system for automatic configuration of "
"services. There are also cases where it prints nothing yet the application "
"clearly is denied access to something. That can be caused by *dontaudit* "
"rules, which silence logging of events that could generate too much noise. "
"In any case a healthy amount of criticism should be applied to everything "
"audit2allow output, especially when the suggested rules would give access "
"rights to outside application directories."
msgstr ""

#: ../../security/selinux.rst:156
msgid ""
"Misconfiguration can cause either file labeling to fail, or the application "
"process not to get transitioned to proper executing context. If it seems "
"that the policy is doing nothing, check that the files are labeled correctly"
" (`ls -lFZ`), and the process is running in the correct context (`ps -efZ`)."
msgstr ""

#: ../../security/selinux.rst:158
msgid ""
"Evaluating the file context rules (fules and their labels) is managed by a "
"heurestic algorithm, which gives precedence to more specific rules by "
"evaluating the length and precision of the path patterns. The patterns are "
"easy for beginner to misconfigure. When suspecting that the file context "
"rules are not getting applied correctly, always investigate `semanage "
"fcontext -l` to see what rules match your files."
msgstr ""

#: ../../security/selinux.rst:161
msgid "Policies for Plone"
msgstr ""

#: ../../security/selinux.rst:163
msgid ""
"The following contains results of ordinary \"install, test & break, add "
"rules, repeat from beginning\" development cycle for a basic Plone SELinux "
"policy."
msgstr ""

#: ../../security/selinux.rst:166
msgid "Relabeling rights"
msgstr ""

#: ../../security/selinux.rst:168
msgid ""
"By default you might not have the right to give any of new security labels "
"to files, and *restorecon* may throw permission denied errors. To give the "
"SELinux utilities (using the context *setfiles_t*) the right to change the "
"security context based on the new types add the following rules: ::"
msgstr ""

#: ../../security/selinux.rst:191
msgid ""
"If the transition is not done, the application will keep running in the "
"starting user's original context. Most likely that will be unconfined_t, "
"which means no SELinux restrictions will be applied to the process."
msgstr ""

#: ../../security/selinux.rst:194
msgid "Transition to context"
msgstr ""

#: ../../security/selinux.rst:196
msgid ""
"When you first run Plone (ie. \"plonectl fg\"), you will notice that it "
"doesn't run, complaining about bad interpreter. Audit2allow will instruct to"
" give rights to your uncontained_t context to run the python interpreter. "
"This is however wrong. You wish to first instruct SELinux to change the "
"process always to the new context (*plonectl_exec_t*) when the application "
"is run. You also wish to have the necessary rights to execute the "
"application so that the context transition can start: ::"
msgstr ""

#: ../../security/selinux.rst:214
msgid ""
"Later when enough rules are in place for the application to run take a look "
"at the process context to see that the transitioning to *plonectl_exec_t* "
"works: ::"
msgstr ""

#: ../../security/selinux.rst:221
msgid "Common process requirements"
msgstr ""

#: ../../security/selinux.rst:223
msgid ""
"In order for any \\*NIX process to work some basic requirements must be met."
" Applications require for instance access to /dev/null, and PTYs: ::"
msgstr ""

#: ../../security/selinux.rst:234
msgid "Zope/PLONE"
msgstr ""

#: ../../security/selinux.rst:236
msgid ""
"After running the plonectl commands (fg, start, stop) several times, and "
"adding the required rules you should end up with something like following. "
"First you will have a large amount of require stanzas for the rule compiler,"
" and then an intermediate amount of rules: ::"
msgstr ""

#: ../../security/selinux.rst:278
msgid ""
"Gathering the previous audit2allow failed completely to report tcp_socket "
"read and write. Some system policy had probably introduced a *dontaudit* "
"rule, which quiesced the logging for that access vector denial. Luckily "
"Plone threw out very distinct Exception, which made resolving the issue "
"easy."
msgstr ""

#: ../../security/selinux.rst:281
msgid "ZEO"
msgstr ""

#: ../../security/selinux.rst:283
msgid ""
"There are couple differences between standalone and ZEO installations. To "
"support both a boolean is probably good way to go. Booleans can be managed "
"like: ::"
msgstr ""

#: ../../security/selinux.rst:290
msgid ""
"Installing Plone in ZEO mode will change the directory *zinstance* to "
"*zeocluster*. It is alright to either have both defined in **plone.fc**, or "
"to use regexp: ::"
msgstr ""

#: ../../security/selinux.rst:296
msgid ""
"The differences to type enforcement policy consist mostly of more networking"
" abilities (which one probably should not allow unless really required), and"
" the ability to run shells (ie. bash): ::"
msgstr ""

#: ../../security/selinux.rst:316
msgid "Maintenance utilities"
msgstr ""

#: ../../security/selinux.rst:318
msgid ""
"The procedure for allowing maintenance utilities like *buildout* to work is "
"quite straight forward. First introduce a new context: ::"
msgstr ""

#: ../../security/selinux.rst:323
msgid "Then label the maintenance utilities using the context: ::"
msgstr ""

#: ../../security/selinux.rst:327
msgid ""
"Last, provide the necessary rules for relabeling, context transition, and "
"for the process to run without any restrictions: ::"
msgstr ""

#: ../../security/selinux.rst:338
msgid ""
"After running maintenance tasks you should make sure the files have still "
"correct labels by running something like: ::"
msgstr ""

#: ../../security/selinux.rst:343
msgid ""
"See also \"setenforce Permissive\", which will disable enforcing SELinux "
"rules temporarily system wide."
msgstr ""

#: ../../security/selinux.rst:346
msgid "Testing the policy"
msgstr ""

#: ../../security/selinux.rst:348
msgid ""
"Easiest way to test the policy is to label for instance the Python "
"executable as plone_exec_t by using *chcon*, and to test the policy using "
"Python scripts. For example: ::"
msgstr ""

#: ../../security/selinux.rst:369
msgid ""
"This can easily be refined into automated testing. Other forms such as "
"Portlet inside running Plone process can also be used for testing."
msgstr ""

#: ../../security/selinux.rst:372
msgid "Deploying the policy"
msgstr ""

#: ../../security/selinux.rst:374
msgid ""
"SELinux policies can be installed simply by running *semodule -n -i "
"<compiled_policy.pp>*. In case packaging is required (for rolling out Plone "
"instances automatically, or for use with centralized management tools like "
"Satellite) it is easy to accomplish with rpm. In order to do that first "
"install the rpm building tools: ::"
msgstr ""

#: ../../security/selinux.rst:378
msgid "Then modify the following RPM spec file to suit your needs: ::"
msgstr ""

#: ../../security/selinux.rst:438
msgid "The rpm packages will be built by running the rpmbuild: ::"
msgstr ""

#: ../../security/selinux.rst:445
msgid "External resources"
msgstr ""

#: ../../security/selinux.rst:447
msgid ""
"The following external resources are sorted by probable usefulness to "
"someone who is beginning working with SELinux:"
msgstr ""

#: ../../security/selinux.rst:449
msgid ""
"`Fedora SELinux FAQ <https://docs.fedoraproject.org/en-"
"US/Fedora/13/html/SELinux_FAQ/index.html>`_"
msgstr ""

#: ../../security/selinux.rst:450
msgid "`Reference policy API <http://oss.tresys.com/docs/refpolicy/api/>`_"
msgstr ""

#: ../../security/selinux.rst:451
msgid "`NSA - SELinux FAQ <http://www.nsa.gov/research/selinux/faqs.shtml>`_"
msgstr ""

#: ../../security/selinux.rst:452
msgid ""
"`NSA - SELinux main website "
"<http://www.nsa.gov/research/selinux/index.shtml>`_"
msgstr ""

#: ../../security/selinux.rst:453
msgid "`Official SELinux project wiki <http://selinuxproject.org/>`_"
msgstr ""

#: ../../security/selinux.rst:454
msgid ""
"`Red Hat Enterprise SELinux Policy Administration (RHS429) classroom course "
"<https://www.redhat.com/training/courses/rhs429/>`_"
msgstr ""

#: ../../security/selinux.rst:455
msgid ""
"`Tresys Open Source projects <http://www.tresys.com/open-source.php>`_ (IDE,"
" documentation about the reference policy, and several management tools)"
msgstr ""
